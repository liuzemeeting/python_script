    main()

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import unicode_literals



from os import getenv, makedirs

from os.path import exists as path_exists, isfile, join as path_join



from py2neo.internal.compat import urlretrieve

from py2neo.internal.versioning import Version





editions = [

    "community",

    "enterprise",

]



versions = [



    # 3.0 series

    "3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.0.4", "3.0.5", "3.0.6", "3.0.7", "3.0.8", "3.0.9",

    "3.0.10", "3.0.11", "3.0.12",



    # 3.1 series

    "3.1.0", "3.1.1", "3.1.2", "3.1.3", "3.1.4", "3.1.5", "3.1.6", "3.1.7", "3.1.8", "3.1.9",



    # 3.2 series

    "3.2.0", "3.2.1", "3.2.2", "3.2.3", "3.2.5", "3.2.6", "3.2.7", "3.2.8", "3.2.9", "3.2.10",

    "3.2.11", "3.2.12", "3.2.13",



    # 3.3 series

    "3.3.0", "3.3.1", "3.3.2", "3.3.3", "3.3.4", "3.3.5", "3.3.6", "3.3.7", "3.3.8", "3.3.9",



    # 3.4 series

    "3.4.0", "3.4.1", "3.4.2", "3.4.3", "3.4.4", "3.4.5", "3.4.6", "3.4.7", "3.4.8", "3.4.9",

    "3.4.10",



    # 3.5 series

    "3.5.0",



]



# TODO: make this a bit easier to read

version_tuples = [Version.parse(v) for v in versions]

minor_version_tuples = sorted({v.major_minor for v in version_tuples})

minor_versions = [".".join(map(str, v)) for v in minor_version_tuples]

latest_version_tuples = {w: sorted(v.major_minor_patch for v in version_tuples if v.major_minor == w)[-1]

                         for w in minor_version_tuples}

latest_versions = {".".join(map(str, k)): ".".join(map(str, v)) for k, v in latest_version_tuples.items()}

version_aliases = dict(latest_versions, **{k + "-LATEST": v for k, v in latest_versions.items()})

version_aliases["LATEST"] = versions[-1]



dist = "http://{}".format(getenv("NEO4J_DIST_HOST") or "dist.neo4j.org")

dist_overrides = {

    # "3.0.0-NIGHTLY": "http://alpha.neohq.net/dist",

}



archive_format = getenv("ARCHIVE_FORMAT") or "gz"





class Distribution(object):

    """ Represents a Neo4j archive.

    """



    def __init__(self, edition=None, version=None):

        edition = edition.lower() if edition else "community"

        if edition in editions:

            self.edition = edition

        else:

            raise ValueError("Unknown edition %r" % edition)

        version = version.upper() if version else "LATEST"

        self.snapshot = "SNAPSHOT" in version

        if version in version_aliases:

            version = version_aliases[version]

        if version in versions:

            self.version = version

        else:

            raise ValueError("Unknown version %r" % version)



    @property

    def key(self):

        """ The unique key that identifies the archive, e.g.

        ``community-2.3.2``.

        """

        return "%s-%s" % (self.edition, self.version)



    @property

    def name(self):

        """ The full name of the archive file, e.g.

        ``neo4j-community-2.3.2-unix.tar.gz``.

        """

        return "neo4j-{}-unix.tar.{}".format(self.key, archive_format)



    @property

    def uri(self):

        """ The URI from which this archive may be downloaded, e.g.

        ``http://dist.neo4j.org/neo4j-community-2.3.2-unix.tar.gz``.

        """

        if self.version in dist_overrides:

            return "%s/%s" % (dist_overrides[self.version], self.name)

        else:

            return "%s/%s" % (dist, self.name)



    def download(self, path=".", overwrite=False):

        """ Download a Neo4j distribution to the specified path.



        :param path:

        :param overwrite:

        :return: the name of the downloaded file

        """

        file_name = path_join(path, self.name)

        if overwrite:

            if path_exists(file_name) and not isfile(file_name):

                raise IOError("Cannot overwrite directory %r" % file_name)

        elif not self.snapshot and path_exists(file_name):

            return file_name

        try:

            makedirs(path)

        except OSError:

            pass

        print("Downloading <%s>" % self.uri)

        urlretrieve(self.uri, file_name)

        return file_name

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from hashlib import sha256

from os import curdir, getenv, kill, listdir, makedirs, rename

from os.path import abspath, dirname, expanduser, isdir, isfile, join as path_join

from random import randint

from re import compile as re_compile

from shutil import rmtree

from socket import create_connection

from subprocess import check_call, check_output, CalledProcessError

from tarfile import TarFile, ReadError

from time import sleep, time

from warnings import warn



from py2neo.admin.dist import Distribution, archive_format

from py2neo.internal.compat import bstr, SocketError





def hex_bytes(data):

    return "".join("%02X" % b for b in bytearray(data)).encode("utf-8")





def unhex_bytes(h):

    h = bytes(h)

    return bytearray(int(h[i:(i + 2)], 0x10) for i in range(0, len(h), 2))





class Warehouse(object):

    """ A local storage area for Neo4j installations.

    """



    def __init__(self, home=None):

        self.home = home or getenv("PY2NEO_HOME") or expanduser("~/.py2neo")

        self.dist = path_join(self.home, "dist")

        self.run = path_join(self.home, "run")

        self.cc = path_join(self.home, "cc")



    def get(self, name, database=None, role=None, member=None):

        """ Obtain a Neo4j installation by name.



        :param name:

        :param database:

        :param role:

        :param member:

        :return:

        """

        if database and role and member is not None:

            container = path_join(self.cc, name, database, role, str(member))

        else:

            container = path_join(self.run, name)

        for dir_name in listdir(container):

            dir_path = path_join(container, dir_name)

            if isdir(dir_path):

                return Installation(dir_path)

        raise IOError("Could not locate installation directory")



    def install(self, name, edition=None, version=None, database=None, role=None, member=None):

        """ Install Neo4j.



        :param name:

        :param edition:

        :param version:

        :param database:

        :param role:

        :param member:

        :return:

        """

        if database and role and member is not None:

            container = path_join(self.cc, name, database, role, str(member))

        else:

            container = path_join(self.run, name)

        rmtree(container, ignore_errors=True)

        makedirs(container)

        archive_file = Distribution(edition, version).download(self.dist)

        try:

            with TarFile.open(archive_file, "r:{}".format(archive_format)) as archive:

                archive.extractall(container)

        except ReadError:

            # The tarfile module sometimes has trouble with certain tar

            # files for unknown reasons. This workaround falls back to

            # command line.

            check_call(["tar", "x", "-C", container, "-f", archive_file])

        return self.get(name, database, role, member)



    def uninstall(self, name, database=None, role=None, member=None):

        """ Remove a Neo4j installation.



        :param name:

        :param database:

        :param role:

        :param member:

        :return:

        """

        if database and role and member is not None:

            container = path_join(self.cc, name, database, role, str(member))

        else:

            container = path_join(self.run, name)

        rmtree(container, ignore_errors=True)



    def directory(self):

        """ Fetch a dictionary of :class:`.Installation` objects, keyed

        by name, for all available Neo4j installations.

        """

        try:

            return {name: self.get(name) for name in listdir(self.run) if not name.startswith(".")}

        except OSError:

            return {}



    def rename(self, name, new_name):

        """ Rename a Neo4j installation.



        :param name:

        :param new_name:

        :return:

        """

        rename(path_join(self.run, name), path_join(self.run, new_name))





class Installation(object):

    """ A Neo4j 3.0+ server installation.

    """



    config_file = "neo4j.conf"



    def __init__(self, home=None):

        self.home = home or abspath(curdir)

        self.server = Server(self)

        self.auth = AuthFile(path_join(self.home, "data", "dbms", "auth"))



    def __repr__(self):

        return "<%s home=%r>" % (self.__class__.__name__, self.home)



    @property

    def store_path(self):

        """ The location of the graph database store on disk.

        """

        return path_join(self.home, "data", "databases",

                         self.get_config("dbms.active_database", "graph.db"))



    def get_config(self, key, default=None):

        """ Retrieve the value of a configuration item.



        :param key:

        :param default:

        :return:

        """

        config_file_path = path_join(self.home, "conf", self.config_file)

        with open(config_file_path, "r") as f_in:

            for line in f_in:

                if line.startswith(key + "="):

                    return line.strip().partition("=")[-1]

        return default



    def set_config(self, key, value):

        """ Update a single configuration value.



        :param key:

        :param value:

        """

        self.update_config({key: value})



    def update_config(self, properties):

        """ Update multiple configuration values.



        :param properties:

        """

        config_file_path = path_join(self.home, "conf", self.config_file)

        with open(config_file_path, "r") as f_in:

            lines = f_in.readlines()

        with open(config_file_path, "w") as f_out:

            properties2 = dict(properties)

            for line in lines:

                for key, value in properties2.items():

                    if line.startswith(key + "=") or \

                            (line.startswith("#") and line[1:].lstrip().startswith(key + "=")):

                        if value is True:

                            value = "true"

                        if value is False:

                            value = "false"

                        f_out.write("%s=%s\n" % (key, value))

                        del properties2[key]

                        break

                else:

                    f_out.write(line)

            for key, value in properties2.items():

                if value is True:

                    value = "true"

                if value is False:

                    value = "false"

                f_out.write("%s=%s\n" % (key, value))



    @property

    def auth_enabled(self):

        """ Settable boolean property for enabling and disabling auth

        on this server.

        """

        return self.get_config("dbms.security.auth_enabled", "true") == "true"



    @auth_enabled.setter

    def auth_enabled(self, value):

        self.set_config("dbms.security.auth_enabled", value)



    def _get_protocol_address(self, protocol, default_port):

        if self.get_config("dbms.connector.%s.enabled" % protocol, "true") != "true":

            raise ValueError("Protocol %r not enabled" % protocol)

        address = self.get_config("dbms.connector.%s.listen_address" % protocol)

        if address:

            host, _, port = address.partition(":")

            try:

                port = int(port)

            except (TypeError, ValueError):

                pass

            return host or "localhost", port

        return "localhost", default_port



    def _set_protocol_address(self, protocol, address):

        host, port = address

        self.set_config("dbms.connector.%s.listen_address" % protocol, "%s:%s" % (host, port))



    @property

    def http_address(self):

        """ The host and port on which this server expects HTTP communication.



        :returns: 2-tuple of (host, port)

        """

        return self._get_protocol_address("http", 7474)



    @http_address.setter

    def http_address(self, address):

        """ Set the host and port on which this server expects HTTP communication.

        """

        self._set_protocol_address("http", address)



    @property

    def https_address(self):

        """ The host and port on which this server expects HTTPS communication.



        :returns: 2-tuple of (host, port)

        """

        return self._get_protocol_address("https", 7473)



    @https_address.setter

    def https_address(self, address):

        """ Set the host and port on which this server expects HTTPS communication.

        """

        self._set_protocol_address("https", address)



    @property

    def bolt_address(self):

        """ The host and port on which this server expects Bolt communication.



        :returns: 2-tuple of (host, port)

        """

        return self._get_protocol_address("bolt", 7687)



    @bolt_address.setter

    def bolt_address(self, address):

        """ Set the host and port on which this server expects Bolt communication.

        """

        self._set_protocol_address("bolt", address)



    @property

    def http_uri(self):

        """ The full HTTP URI for this server.

        """

        host, port = self.http_address

        return "http://%s:%s" % (host, port)



    @property

    def https_uri(self):

        """ The full HTTPS URI for this server.

        """

        host, port = self.https_address

        return "https://%s:%s" % (host, port)



    @property

    def bolt_uri(self):

        """ The full Bolt URI for this server.

        """

        host, port = self.bolt_address

        return "bolt://%s:%s" % (host, port)



    def delete_store(self, force=False):

        """ Delete the store directory for this server.



        :param force:

        """

        if force or not self.server.running():

            try:

                rmtree(self.store_path, ignore_errors=force)

            except FileNotFoundError:

                pass

        else:

            raise RuntimeError("Refusing to drop database store while server is running")





class Server(object):

    """ Represents a Neo4j server process that can be started and stopped.

    """



    @classmethod

    def wait_until_listening(cls, address, wait):

        listening = False

        t0 = time()

        while not listening and (time() - t0) < wait:

            try:

                s = create_connection(address)

            except (OSError, SocketError):

                sleep(0.5)

            else:

                s.close()

                listening = True

        if not listening:

            warn("Timed out waiting for server to start at address %r" % (address,))

        return listening



    def __init__(self, installation):

        self.installation = installation



    @property

    def control_script(self):

        return path_join(self.installation.home, "bin", "neo4j")



    def start(self, wait=300, verbose=False):

        """ Start the server.

        """

        try:

            out = check_output("%s start" % self.control_script, shell=True)

        except CalledProcessError as error:

            if error.returncode == 2:

                raise OSError("Another process is listening on the server port")

            elif error.returncode == 512:

                raise OSError("Another server process is already running")

            else:

                raise OSError("An error occurred while trying to start "

                              "the server [%s]" % error.returncode)

        else:

            pid = None

            for line in out.decode("utf-8").splitlines(False):

                if verbose:

                    print(line)

                if line.startswith("process"):

                    number_in_brackets = re_compile(r"\[(\d+)\]")

                    numbers = number_in_brackets.search(line).groups()

                    if numbers:

                        pid = int(numbers[0])

                elif "(pid " in line:

                    pid = int(line.partition("(pid ")[-1].partition(")")[0])

            self.wait_until_listening(self.installation.bolt_address, wait)

            self.wait_until_listening(self.installation.http_address, wait)

            self.wait_until_listening(self.installation.https_address, wait)

            return pid



    def stop(self):

        """ Stop the server.

        """

        pid = self.running()

        if not pid:

            return

        try:

            check_output(("%s stop" % self.control_script), shell=True)

        except CalledProcessError as error:

            raise OSError("An error occurred while trying to stop the server "

                          "[%s]" % error.returncode)

        while pid:

            try:

                kill(pid, 0)

            except OSError:

                pid = 0

            else:

                pass



    def restart(self):

        """ Restart the server.

        """

        self.stop()

        return self.start()



    def running(self):

        """ The PID of the current executing process for this server.

        """

        try:

            out = check_output(("%s status" % self.control_script), shell=True)

        except CalledProcessError as error:

            if error.returncode == 3:

                return None

            else:

                raise OSError("An error occurred while trying to query the "

                              "server status [%s]" % error.returncode)

        else:

            p = None

            for line in out.decode("utf-8").splitlines(False):

                if "running" in line:

                    p = int(line.rpartition(" ")[-1])

            return p





class AuthFile(object):

    """ A Neo4j auth file, generally located at data/dbms/auth.

    """



    def __init__(self, name):

        self.name = name

        if not isfile(self.name):

            d = dirname(self.name)

            try:

                makedirs(d)

            except OSError:

                pass

            with open(self.name, "wb"):

                pass



    def __iter__(self):

        with open(self.name, "rb") as f:

            for line in f:

                yield AuthUser.load(line)



    def remove(self, user_name):

        """ Remove a user.

        """

        user_name = bstr(user_name)

        with open(self.name, "rb") as f:

            lines = [line for line in f.readlines() if not AuthUser.match(line, user_name)]

        with open(self.name, "wb") as f:

            f.writelines(lines)



    def update(self, user_name, password):

        """ Add or update a user.

        """

        user_name = bstr(user_name)

        password = bstr(password)

        updated = False

        with open(self.name, "rb") as f:

            lines = []

            for line in f.readlines():

                if AuthUser.match(line, user_name):

                    lines.append(AuthUser.create(user_name, password).dump())

                    updated = True

                else:

                    lines.append(line)

        if not updated:

            lines.append(AuthUser.create(user_name, password).dump())

        with open(self.name, "wb") as f:

            f.writelines(lines)





class AuthUser(object):



    #: Name of user

    name = None



    #: The hash algorithm mused to encode the user data

    hash_algorithm = None



    #:

    digest = None



    #:

    salt = None



    @classmethod

    def create(cls, user_name, password):

        user_name = bstr(user_name)

        password = bstr(password)

        inst = cls(user_name, b"SHA-256", None, None)

        inst.set_password(password)

        return inst



    @classmethod

    def load(cls, s):

        s = bstr(s)

        fields = s.rstrip().split(b":")

        name = fields[0]

        hash_algorithm, digest, salt = fields[1].split(b",")

        return cls(name, hash_algorithm, unhex_bytes(digest), unhex_bytes(salt))



    @classmethod

    def match(cls, s, user_name):

        s = bstr(s)

        user_name = bstr(user_name)

        candidate_user_name, _, _ = s.partition(b":")

        return candidate_user_name == user_name



    def dump(self, eol=b"\r\n"):

        return self.name + b":" + self.hash_algorithm + b"," + hex_bytes(self.digest) + b"," + \

               hex_bytes(self.salt) + b":" + bstr(eol)



    def __init__(self, name, hash_algorithm, digest, salt):

        assert hash_algorithm == b"SHA-256"

        self.name = bstr(name)

        self.hash_algorithm = bstr(hash_algorithm)

        self.digest = digest

        self.salt = salt



    def __repr__(self):

        return "<AuthUser name=%r>" % self.name



    def set_password(self, password):

        assert self.hash_algorithm == b"SHA-256"

        salt = bytearray(randint(0x00, 0xFF) for _ in range(16))

        m = sha256()

        m.update(salt)

        m.update(bstr(password))

        self.digest = m.digest()

        self.salt = salt



    def check_password(self, password):

        assert self.hash_algorithm == b"SHA-256"

        m = sha256()

        m.update(self.salt)

        m.update(bstr(password))

        return m.digest() == self.digest

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from os import environ

from os.path import expanduser, join as path_join



from py2neo.meta import __version__





EDITOR = environ.get("EDITOR", "vim")



HISTORY_FILE_DIR = expanduser(path_join("~", ".py2neo"))



HISTORY_FILE = "console_history"



TITLE = "Py2neo console v{}".format(__version__)



DESCRIPTION = "Py2neo console is a Cypher runner and interactive tool for Neo4j."



QUICK_HELP = """\

  //  to enter multi-line mode (press [Alt]+[Enter] to run)

  /e  to launch external editor

  /?  for help

  /x  to exit\

"""



FULL_HELP = """\

If command line arguments are provided, these are executed in order as

statements. If no arguments are provided, an interactive console is

presented.



Statements entered at the interactive prompt or as arguments can be

regular Cypher, transaction control keywords or slash commands. Multiple

Cypher statements can be entered on the same line separated by semicolons.

These will be executed within a single transaction.



For a handy Cypher reference, see:



  https://neo4j.com/docs/cypher-refcard/current/



Transactions can be managed interactively. To do this, use the transaction

control keywords BEGIN, COMMIT and ROLLBACK.



Slash commands provide access to supplementary functionality.



\b

{}



\b

Execution commands:

  /play     run a query from a file



\b

Formatting commands:

  /csv      format output as comma-separated values

  /table    format output in a table

  /tsv      format output as tab-separated values



\b

Information commands:

  /config   show Neo4j server configuration

  /kernel   show Neo4j kernel information



Report bugs to py2neo@nige.tech\

""".format(QUICK_HELP)

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import division, print_function



import shlex

from datetime import datetime

from os import makedirs

from os.path import expanduser, join as path_join

from subprocess import call

from tempfile import NamedTemporaryFile

from textwrap import dedent

from timeit import default_timer as timer



import click

from neobolt.exceptions import ServiceUnavailable, CypherError

from prompt_toolkit import prompt

from prompt_toolkit.history import FileHistory

from prompt_toolkit.lexers import PygmentsLexer

from prompt_toolkit.styles import merge_styles, style_from_pygments_cls, style_from_pygments_dict

from pygments.styles.native import NativeStyle

from pygments.token import Token



from py2neo.console.meta import HISTORY_FILE_DIR, HISTORY_FILE, TITLE, QUICK_HELP, EDITOR, DESCRIPTION, FULL_HELP

from py2neo.cypher.lexer import CypherLexer

from py2neo.data import Table

from py2neo.database import Graph

from py2neo.internal.connectors import get_connection_data





def is_command(source):

    if source == "//":

        return True

    if source.startswith("//"):

        return False

    if source.startswith("/*"):

        return False

    return source.startswith("/")





class Console(object):



    def echo(self, text, file=None, nl=True, err=False, color=None, **styles):

        return click.secho(text, file=file, nl=nl, err=err, color=color, **styles)



    def prompt(self, *args, **kwargs):

        return prompt(*args, **kwargs)



    multi_line = False

    watcher = None



    tx_colour = "yellow"

    err_colour = "reset"

    meta_colour = "cyan"

    prompt_colour = "cyan"



    def __init__(self, uri=None, **settings):

        self.output_file = settings.pop("file", None)

        verbose = settings.pop("verbose", False)

        connection_data = get_connection_data(uri, **settings)

        try:

            self.graph = Graph(uri, **settings)

        except ServiceUnavailable as error:

            raise ConsoleError("Could not connect to {} -- {}".format(connection_data["uri"], error))

        try:

            makedirs(HISTORY_FILE_DIR)

        except OSError:

            pass

        self.history = FileHistory(path_join(HISTORY_FILE_DIR, HISTORY_FILE))

        self.prompt_args = {

            "history": self.history,

            "lexer": PygmentsLexer(CypherLexer),

            "style": merge_styles([

                style_from_pygments_cls(NativeStyle),

                style_from_pygments_dict({

                    Token.Prompt: "#ansi{}".format(self.prompt_colour.replace("cyan", "teal")),

                    Token.TxCounter: "#ansi{} bold".format(self.tx_colour.replace("cyan", "teal")),

                })

            ])

        }

        self.lexer = CypherLexer()

        self.result_writer = Table.write

        if verbose:

            from neobolt.diagnostics import watch

            self.watcher = watch("neo4j.%s" % connection_data["scheme"])



        self.commands = {



            "//": self.set_multi_line,

            "/e": self.edit,



            "/?": self.help,

            "/h": self.help,

            "/help": self.help,



            "/x": self.exit,

            "/exit": self.exit,



            "/play": self.play,



            "/csv": self.set_csv_result_writer,

            "/table": self.set_tabular_result_writer,

            "/tsv": self.set_tsv_result_writer,



            "/config": self.config,

            "/kernel": self.kernel,



        }

        self.tx = None

        self.tx_counter = 0



    def loop(self):

        self.echo(TITLE, err=True)

        self.echo("Connected to {}".format(self.graph.database.uri).rstrip(), err=True)

        self.echo(u"", err=True)

        self.echo(dedent(QUICK_HELP), err=True)

        while True:

            try:

                source = self.read()

            except KeyboardInterrupt:

                continue

            except EOFError:

                return 0

            try:

                self.run(source)

            except ServiceUnavailable:

                return 1



    def run_all(self, sources):

        gap = False

        for s in sources:

            if gap:

                self.echo("")

            self.run(s)

            if not is_command(s):

                gap = True

        return 0



    def run(self, source):

        source = source.strip()

        if not source:

            return

        try:

            if is_command(source):

                self.run_command(source)

            else:

                self.run_source(source)

        except CypherError as error:

            if error.classification == "ClientError":

                pass

            elif error.classification == "DatabaseError":

                pass

            elif error.classification == "TransientError":

                pass

            else:

                pass

            self.echo("{}: {}".format(error.title, error.message), err=True)

        # except TransactionError:

        #     self.echo("Transaction error", err=True, fg=self.err_colour)

        except ServiceUnavailable:

            raise

        except Exception as error:

            self.echo("{}: {}".format(error.__class__.__name__, str(error)), err=True, fg=self.err_colour)



    def begin_transaction(self):

        if self.tx is None:

            self.tx = self.graph.begin()

            self.tx_counter = 1

            self.echo(u"--- BEGIN at {} ---".format(datetime.now()),

                      err=True, fg=self.tx_colour, bold=True)

        else:

            self.echo(u"Transaction already open", err=True, fg=self.err_colour)



    def commit_transaction(self):

        if self.tx:

            try:

                self.tx.commit()

                self.echo(u"--- COMMIT at {} ---".format(datetime.now()),

                          err=True, fg=self.tx_colour, bold=True)

            finally:

                self.tx = None

                self.tx_counter = 0

        else:

            self.echo(u"No current transaction", err=True, fg=self.err_colour)



    def rollback_transaction(self):

        if self.tx:

            try:

                self.tx.rollback()

                self.echo(u"--- ROLLBACK at {} ---".format(datetime.now()),

                          err=True, fg=self.tx_colour, bold=True)

            finally:

                self.tx = None

                self.tx_counter = 0

        else:

            self.echo(u"No current transaction", err=True, fg=self.err_colour)



    def read(self):

        if self.multi_line:

            self.multi_line = False

            return self.prompt(u"", multiline=True, **self.prompt_args)



        def get_prompt_tokens():

            tokens = []

            if self.tx is None:

                tokens.append(("class:pygments.prompt", "\n-> "))

            else:

                tokens.append(("class:pygments.prompt", "\n-("))

                tokens.append(("class:pygments.txcounter", "{}".format(self.tx_counter)))

                tokens.append(("class:pygments.prompt", ")-> "))

            return tokens



        return self.prompt(get_prompt_tokens, **self.prompt_args)



    def run_source(self, source):

        for i, statement in enumerate(self.lexer.get_statements(source)):

            if i > 0:

                self.echo(u"")

            if statement.upper() == "BEGIN":

                self.begin_transaction()

            elif statement.upper() == "COMMIT":

                self.commit_transaction()

            elif statement.upper() == "ROLLBACK":

                self.rollback_transaction()

            elif self.tx is None:

                self.run_cypher(self.graph.run, statement, {})

            else:

                self.run_cypher(self.tx.run, statement, {}, line_no=self.tx_counter)

                self.tx_counter += 1



    def run_cypher(self, runner, statement, parameters, line_no=0):

        t0 = timer()

        result = runner(statement, parameters)

        record_count = self.write_result(result)

        summary = result.summary()

        status = u"{} record{} from {} in {:.3f}s".format(

            record_count,

            "" if record_count == 1 else "s",

            summary.connection["uri"],

            timer() - t0,

        )

        if line_no:

            self.echo(u"(", err=True, fg=self.meta_colour, bold=True, nl=False)

            self.echo(u"{}".format(line_no), err=True, fg=self.tx_colour, bold=True, nl=False)

            self.echo(u")->({})".format(status), err=True, fg=self.meta_colour, bold=True)

        else:

            self.echo(u"({})".format(status), err=True, fg=self.meta_colour, bold=True)



    def write_result(self, result, page_size=50):

        table = Table(result)

        table_size = len(table)

        for skip in range(0, table_size, page_size):

            self.result_writer(table, file=self.output_file, header={"fg": "cyan", "bold": True}, skip=skip, limit=page_size)

            self.echo("\r\n", nl=False)

        return table_size



    def run_command(self, source):

        source = source.lstrip()

        assert source

        terms = shlex.split(source)

        command_name = terms[0]

        try:

            command = self.commands[command_name]

        except KeyError:

            self.echo("Unknown command: " + command_name, err=True, fg=self.err_colour)

        else:

            args = []

            kwargs = {}

            for term in terms[1:]:

                if "=" in term:

                    key, _, value = term.partition("=")

                    kwargs[key] = value

                else:

                    args.append(term)

            command(*args, **kwargs)



    def set_multi_line(self, **kwargs):

        self.multi_line = True



    def edit(self, **kwargs):

        initial_message = b""

        with NamedTemporaryFile(suffix=".cypher") as f:

            f.write(initial_message)

            f.flush()

            call([EDITOR, f.name])

            f.seek(0)

            source = f.read().decode("utf-8")

            self.echo(source)

            self.run(source)



    def help(self, **kwargs):

        self.echo(DESCRIPTION, err=True)

        self.echo(u"", err=True)

        self.echo(FULL_HELP.replace("\b\n", ""), err=True)



    def exit(self, **kwargs):

        exit(0)



    def play(self, file_name):

        work = self.load_unit_of_work(file_name=file_name)

        with self.graph.begin() as tx:

            work(tx)



    def load_unit_of_work(self, file_name):

        """ Load a transaction function from a cypher source file.

        """

        with open(expanduser(file_name)) as f:

            source = f.read()



        def unit_of_work(tx):

            for line_no, statement in enumerate(self.lexer.get_statements(source), start=1):

                if line_no > 0:

                    self.echo(u"")

                self.run_cypher(tx.run, statement, {}, line_no=line_no)



        return unit_of_work



    def set_csv_result_writer(self, **kwargs):

        self.result_writer = Table.write_csv



    def set_tabular_result_writer(self, **kwargs):

        self.result_writer = Table.write



    def set_tsv_result_writer(self, **kwargs):

        self.result_writer = Table.write_tsv



    def config(self, **kwargs):

        result = self.graph.run("CALL dbms.listConfig")

        records = None

        last_category = None

        for record in result:

            name = record["name"]

            category, _, _ = name.partition(".")

            if category != last_category:

                if records is not None:

                    Table(records, ["name", "value"]).write(auto_align=False, padding=0, separator=u" = ")

                    self.echo(u"")

                records = []

            records.append((name, record["value"]))

            last_category = category

        if records is not None:

            Table(records, ["name", "value"]).write(auto_align=False, padding=0, separator=u" = ")



    def kernel(self, **kwargs):

        result = self.graph.run("CALL dbms.queryJmx", {"query": "org.neo4j:instance=kernel#0,name=Kernel"})

        records = []

        for record in result:

            attributes = record["attributes"]

            for key, value_dict in sorted(attributes.items()):

                value = value_dict["value"]

                if key.endswith("Date") or key.endswith("Time"):

                    try:

                        value = datetime.fromtimestamp(value / 1000).isoformat(" ")

                    except:

                        pass

                records.append((key, value))

        Table(records, ["key", "value"]).write(auto_align=False, padding=0, separator=u" = ")





class ConsoleError(Exception):



    pass

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





"""

This module provides facilities for encoding values into Cypher

identifiers and literals.

"""



from __future__ import absolute_import



from collections import OrderedDict

from re import compile as re_compile

from unicodedata import category



from py2neo.internal.collections import SetView

from py2neo.internal.compat import uchr, ustr, numeric_types, string_types, unicode_types





ID_START = {u"_"} | {uchr(x) for x in range(0xFFFF)

                     if category(uchr(x)) in ("LC", "Ll", "Lm", "Lo", "Lt", "Lu", "Nl")}

ID_CONTINUE = ID_START | {uchr(x) for x in range(0xFFFF)

                          if category(uchr(x)) in ("Mn", "Mc", "Nd", "Pc", "Sc")}



DOUBLE_QUOTE = u'"'

SINGLE_QUOTE = u"'"



ESCAPED_DOUBLE_QUOTE = u'\\"'

ESCAPED_SINGLE_QUOTE = u"\\'"



X_ESCAPE = re_compile(r"(\\x([0-9a-f]{2}))")

DOUBLE_QUOTED_SAFE = re_compile(r"([ -!#-\[\]-~]+)")

SINGLE_QUOTED_SAFE = re_compile(r"([ -&(-\[\]-~]+)")





class LabelSetView(SetView):



    def __init__(self, elements=(), selected=(), **kwargs):

        super(LabelSetView, self).__init__(frozenset(elements))

        self.__selected = tuple(selected)

        self.__kwargs = kwargs

        self.__encoder = CypherEncoder(**kwargs)



    def __repr__(self):

        if self.__selected:

            return "".join(":%s" % self.__encoder.encode_key(e) for e in self.__selected if e in self)

        else:

            return "".join(":%s" % self.__encoder.encode_key(e) for e in sorted(self))



    def __getattr__(self, element):

        if element in self.__selected:

            return self.__class__(self, self.__selected)

        else:

            return self.__class__(self, self.__selected + (element,))





class PropertyDictView(object):



    def __init__(self, items=(), selected=(), **kwargs):

        self.__items = dict(items)

        self.__selected = tuple(selected)

        self.__encoder = CypherEncoder(**kwargs)



    def __repr__(self):

        if self.__selected:

            properties = OrderedDict((key, self.__items[key]) for key in self.__selected if key in self.__items)

        else:

            properties = OrderedDict((key, self.__items[key]) for key in sorted(self.__items))

        return self.__encoder.encode_value(properties)



    def __getattr__(self, key):

        if key in self.__selected:

            return self.__class__(self.__items, self.__selected)

        else:

            return self.__class__(self.__items, self.__selected + (key,))



    def __len__(self):

        return len(self.__items)



    def __iter__(self):

        return iter(self.__items)



    def __contains__(self, key):

        return key in self.__items





class PropertySelector(object):



    def __init__(self, items=(), default_value=None, **kwargs):

        self.__items = dict(items)

        self.__default_value = default_value

        self.__encoder = CypherEncoder(**kwargs)

        self.__encoding = kwargs.get("encoding", "utf-8")



    def __getattr__(self, key):

        value = self.__items.get(key, self.__default_value)

        if isinstance(value, unicode_types):

            return value

        elif isinstance(value, string_types):

            return value.decode(self.__encoding)

        else:

            return self.__encoder.encode_value(value)





class CypherEncoder(object):



    __default_instance = None



    def __new__(cls, *args, **kwargs):

        if not kwargs:

            if cls.__default_instance is None:

                cls.__default_instance = super(CypherEncoder, cls).__new__(cls)

            return cls.__default_instance

        return super(CypherEncoder, cls).__new__(cls)



    encoding = "utf-8"

    quote = None

    sequence_separator = u", "

    key_value_separator = u": "

    node_template = u"{id}{labels} {properties}"

    related_node_template = u"{name}"

    relationship_template = u"{type} {properties}"



    def __init__(self, encoding=None, quote=None, sequence_separator=None, key_value_separator=None,

                 node_template=None, related_node_template=None, relationship_template=None):

        if encoding:

            self.encoding = encoding

        if quote:

            self.quote = quote

        if sequence_separator:

            self.sequence_separator = sequence_separator

        if key_value_separator:

            self.key_value_separator = key_value_separator

        if node_template:

            self.node_template = node_template

        if related_node_template:

            self.related_node_template = related_node_template

        if relationship_template:

            self.relationship_template = relationship_template



    def encode_key(self, key):

        key = ustr(key)

        if not key:

            raise ValueError("Keys cannot be empty")

        if key[0] in ID_START and all(key[i] in ID_CONTINUE for i in range(1, len(key))):

            return key

        else:

            return u"`" + key.replace(u"`", u"``") + u"`"



    def encode_value(self, value):

        from py2neo.data import Node, Relationship, Path

        from neotime import Date, Time, DateTime, Duration

        if value is None:

            return u"null"

        if value is True:

            return u"true"

        if value is False:

            return u"false"

        if isinstance(value, numeric_types):

            return ustr(value)

        if isinstance(value, string_types):

            return self.encode_string(value)

        if isinstance(value, Node):

            return self.encode_node(value)

        if isinstance(value, Relationship):

            return self.encode_relationship(value)

        if isinstance(value, Path):

            return self.encode_path(value)

        if isinstance(value, list):

            return self.encode_list(value)

        if isinstance(value, dict):

            return self.encode_map(value)

        if isinstance(value, Date):

            return u"date({})".format(self.encode_string(value.iso_format()))

        if isinstance(value, Time):

            return u"time({})".format(self.encode_string(value.iso_format()))

        if isinstance(value, DateTime):

            return u"datetime({})".format(self.encode_string(value.iso_format()))

        if isinstance(value, Duration):

            return u"duration({})".format(self.encode_string(value.iso_format()))

        raise TypeError("Cypher literal values of type %s.%s are not supported" %

                        (type(value).__module__, type(value).__name__))



    def encode_string(self, value):

        value = ustr(value)



        quote = self.quote

        if quote is None:

            num_single = value.count(u"'")

            num_double = value.count(u'"')

            quote = SINGLE_QUOTE if num_single <= num_double else DOUBLE_QUOTE



        if quote == SINGLE_QUOTE:

            escaped_quote = ESCAPED_SINGLE_QUOTE

            safe = SINGLE_QUOTED_SAFE

        elif quote == DOUBLE_QUOTE:

            escaped_quote = ESCAPED_DOUBLE_QUOTE

            safe = DOUBLE_QUOTED_SAFE

        else:

            raise ValueError("Unsupported quote character %r" % quote)



        if not value:

            return quote + quote



        parts = safe.split(value)

        for i in range(0, len(parts), 2):

            parts[i] = (X_ESCAPE.sub(u"\\\\u00\\2", parts[i].encode("unicode-escape").decode("utf-8")).

                        replace(quote, escaped_quote).replace(u"\\u0008", u"\\b").replace(u"\\u000c", u"\\f"))

        return quote + u"".join(parts) + quote



    def encode_list(self, values):

        return u"[" + self.sequence_separator.join(map(self.encode_value, values)) + u"]"



    def encode_map(self, values):

        return u"{" + self.sequence_separator.join(self.encode_key(key) + self.key_value_separator +

                                                   self.encode_value(value) for key, value in values.items()) + u"}"



    def encode_node(self, node):

        return self._encode_node(node, self.node_template)



    def encode_relationship(self, relationship):

        nodes = relationship.nodes

        return u"{}-{}->{}".format(

            self._encode_node(nodes[0], self.related_node_template),

            self._encode_relationship_detail(relationship, self.relationship_template),

            self._encode_node(nodes[-1], self.related_node_template),

        )



    def encode_path(self, path):

        encoded = []

        append = encoded.append

        nodes = path.nodes

        for i, relationship in enumerate(path.relationships):

            append(self._encode_node(nodes[i], self.related_node_template))

            related_nodes = relationship.nodes

            if self._node_id(related_nodes[0]) == self._node_id(nodes[i]):

                append(u"-")

                append(self._encode_relationship_detail(relationship, self.relationship_template))

                append(u"->")

            else:

                append(u"<-")

                append(self._encode_relationship_detail(relationship, self.relationship_template))

                append(u"-")

        append(self._encode_node(nodes[-1], self.related_node_template))

        return u"".join(encoded)



    @classmethod

    def _node_id(cls, node):

        return node.identity if hasattr(node, "identity") else node



    def _encode_node(self, node, template):

        return u"(" + template.format(

            id=u"" if node.identity is None else (u"_" + ustr(node.identity)),

            labels=LabelSetView(node.labels, encoding=self.encoding, quote=self.quote),

            properties=PropertyDictView(node, encoding=self.encoding, quote=self.quote),

            property=PropertySelector(node, u""),

            name=node.__name__,

        ).strip() + u")"



    def _encode_relationship_detail(self, relationship, template):

        return u"[" + template.format(

            id=u"" if relationship.identity is None else (u"_" + ustr(relationship.identity)),

            type=u":" + ustr(type(relationship).__name__),

            properties=PropertyDictView(relationship, encoding=self.encoding, quote=self.quote),

            property=PropertySelector(relationship, u""),

            name=relationship.__name__,

        ).strip() + u"]"

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.



"""

This module contains a `Cypher <https://neo4j.com/developer/cypher/>`_ language lexer based on the

`Pygments <http://pygments.org/>`_ `lexer framework <http://pygments.org/docs/lexerdevelopment/>`_.

This can be used to parse statements and expressions for the Cypher variant available in Neo4j 3.4.



To parse a Cypher statement, create a :class:`.CypherLexer` or select by the name `py2neo.cypher`,

then invoke the :meth:`.get_tokens` method::



    >>> from pygments.lexers import get_lexer_by_name

    >>> lexer = get_lexer_by_name("py2neo.cypher")

    >>> list(lexer.get_tokens("MATCH (a:Person)-[:KNOWS]->(b) RETURN a"))

    [(Token.Keyword, 'MATCH'),

     (Token.Text.Whitespace, ' '),

     (Token.Punctuation, '('),

     (Token.Name.Variable, 'a'),

     (Token.Punctuation, ':'),

     (Token.Name.Label, 'Person'),

     (Token.Punctuation, ')-['),

     (Token.Punctuation, ':'),

     (Token.Name.Label, 'KNOWS'),

     (Token.Punctuation, ']->('),

     (Token.Name.Variable, 'b'),

     (Token.Punctuation, ')'),

     (Token.Text.Whitespace, ' '),

     (Token.Keyword, 'RETURN'),

     (Token.Text.Whitespace, ' '),

     (Token.Name.Variable, 'a'),

     (Token.Text.Whitespace, '\\n')]



To split multiple semicolon-separated statements within a single string, use instead the :meth:`.get_statements` method::



    >>> list(lexer.get_statements("CREATE (:Person {name:'Alice'}); MATCH (a:Person {name:'Alice'}) RETURN id(a)"))

    ["CREATE (:Person {name:'Alice'})",

     "MATCH (a:Person {name:'Alice'}) RETURN id(a)"]



"""



import re



from pygments.lexer import RegexLexer, include, bygroups

from pygments.token import Keyword, Punctuation, Comment, Operator, Name, \

    String, Number, Whitespace





__all__ = [

    "cypher_keywords",

    "cypher_pseudo_keywords",

    "cypher_operator_symbols",

    "cypher_operator_words",

    "cypher_constants",

    "neo4j_built_in_functions",

    "neo4j_user_defined_functions",

    "CypherLexer",

]





cypher_keywords = [

    "AS",

    "ASC",

    "ASCENDING",

    "ASSERT",

    "ASSERT EXISTS",

    "CALL",

    "CONSTRAINT ON",

    "CREATE",

    "CREATE UNIQUE",

    "CYPHER",

    "DELETE",

    "DESC",

    "DESCENDING",

    "DETACH DELETE",

    "DO",

    "DROP",

    "EXPLAIN",

    "FIELDTERMINATOR",

    "FOREACH",

    "FROM",

    "GRAPH",

    "GRAPH AT",

    "GRAPH OF",

    "INDEX ON",

    "INTO",

    "IS NODE KEY",

    "IS UNIQUE",

    "LIMIT",

    "LOAD",

    "LOAD CSV",

    "MATCH",

    "MERGE",

    "ON CREATE SET",

    "ON MATCH SET",

    "OPTIONAL MATCH",

    "ORDER BY",

    "PERSIST",

    "_PRAGMA",

    "PROFILE",

    "REMOVE",

    "RELOCATE",

    "RETURN",

    "RETURN DISTINCT",

    "SET",

    "SKIP",

    "SNAPSHOT",

    "SOURCE",

    "START",

    "TARGET",

    "UNION",

    "UNION ALL",

    "UNWIND",

    "USING INDEX",

    "USING JOIN ON",

    "USING PERIODIC COMMIT",

    "USING SCAN",

    "WHERE",

    "WITH",

    "WITH DISTINCT",

    "WITH HEADERS",

    "YIELD",

    ">>",

]

cypher_pseudo_keywords = [

    "BEGIN",

    "COMMIT",

    "ROLLBACK",

]

cypher_operator_symbols = [

    "!=",

    "%",

    "*",

    "+",

    "+=",

    "-",

    ".",

    "/",

    "<",

    "<=",

    "<>",

    "=",

    "=~",

    ">",

    ">=",

    "^",

]

cypher_operator_words = [

    'AND',

    'CASE',

    'CONTAINS',

    'DISTINCT',

    'ELSE',

    'END',

    'ENDS WITH',

    'IN',

    'IS NOT NULL',

    'IS NULL',

    'NOT',

    'OR',

    'STARTS WITH',

    'THEN',

    'WHEN',

    'XOR',

]

cypher_constants = [

    'null',

    'true',

    'false',

]



neo4j_built_in_functions = [

    "abs",

    "acos",

    "all",

    "allShortestPaths",

    "any",

    "asin",

    "atan",

    "atan2",

    "avg",

    "ceil",

    "coalesce",

    "collect",

    "cos",

    "cot",

    "count",

    "degrees",

    "e",

    "endNode",

    "exists",

    "exp",

    "extract",

    "filter",

    "floor",

    "haversin",

    "head",

    "id",

    "keys",

    "labels",

    "last",

    "left",

    "length",

    "log",

    "log10",

    "lTrim",

    "max",

    "min",

    "nodes",

    "none",

    "percentileCont",

    "percentileDisc",

    "pi",

    "distance",

    "point",

    "radians",

    "rand",

    "range",

    "reduce",

    "relationships",

    "replace",

    "reverse",

    "right",

    "round",

    "rTrim",

    "shortestPath",

    "sign",

    "sin",

    "single",

    "size",

    "split",

    "sqrt",

    "startNode",

    "stdDev",

    "stdDevP",

    "substring",

    "sum",

    "tail",

    "tan",

    "timestamp",

    "toBoolean",

    "toFloat",

    "toInteger",

    "toLower",

    "toString",

    "toUpper",

    "properties",

    "trim",

    "type",

]



neo4j_user_defined_functions = [

    "date",

    "date.realtime",

    "date.statement",

    "date.transaction",

    "date.truncate",

    "datetime",

    "datetime.fromepoch",

    "datetime.fromepochmillis",

    "datetime.realtime",

    "datetime.statement",

    "datetime.transaction",

    "datetime.truncate",

    "duration",

    "duration.between",

    "duration.inDays",

    "duration.inMonths",

    "duration.inSeconds",

    "localdatetime",

    "localdatetime.realtime",

    "localdatetime.statement",

    "localdatetime.transaction",

    "localdatetime.truncate",

    "localtime",

    "localtime.realtime",

    "localtime.statement",

    "localtime.transaction",

    "localtime.truncate",

    "randomUUID",

    "time",

    "time.realtime",

    "time.statement",

    "time.transaction",

    "time.truncate"

]





def word_list(words, token_type):

    return list(reversed(sorted((word.replace(" ", r"\s+") + r"\b", token_type) for word in words)))





def symbol_list(symbols, token_type):

    return list(reversed(sorted(("".join("\\" + ch for ch in symbol), token_type) for symbol in symbols)))





class CypherLexer(RegexLexer):

    """ Pygments lexer for the `Cypher Query Language

    <https://neo4j.com/docs/cypher-refcard/current/>`_

    as available in Neo4j 3.4.

    """

    name = "Cypher"

    aliases = ["cypher", "py2neo.cypher"]

    filenames = ["*.cypher", "*.cyp"]



    flags = re.IGNORECASE | re.MULTILINE | re.UNICODE



    tokens = {



        'root': [

            include('strings'),

            include('comments'),

            include('keywords'),

            include('pseudo-keywords'),

            include('escape-commands'),

            (r'[,;]', Punctuation),

            include('labels'),

            include('operators'),

            include('expressions'),

            include('whitespace'),

            (r'\(', Punctuation, 'in-()'),

            (r'\[', Punctuation, 'in-[]'),

            (r'\{', Punctuation, 'in-{}'),

        ],

        'in-()': [

            include('strings'),

            include('comments'),

            include('keywords'),        # keywords used in FOREACH

            (r'[,|]', Punctuation),

            include('labels'),

            include('operators'),

            include('expressions'),

            include('whitespace'),

            (r'\(', Punctuation, '#push'),

            (r'\)\s*<?-+>?\s*\(', Punctuation),

            (r'\)\s*<?-+\s*\[', Punctuation, ('#pop', 'in-[]')),

            (r'\)', Punctuation, '#pop'),

            (r'\[', Punctuation, 'in-[]'),

            (r'\{', Punctuation, 'in-{}'),

        ],

        'in-[]': [

            include('strings'),

            include('comments'),

            (r'WHERE\b', Keyword),      # used in list comprehensions

            (r'[,|]', Punctuation),

            include('labels'),

            include('operators'),

            include('expressions'),

            include('whitespace'),

            (r'\(', Punctuation, 'in-()'),

            (r'\[', Punctuation, '#push'),

            (r'\]\s*-+>?\s*\(', Punctuation, ('#pop', 'in-()')),

            (r'\]', Punctuation, '#pop'),

            (r'\{', Punctuation, 'in-{}'),

        ],

        'in-{}': [

            include('strings'),

            include('comments'),

            (r'[,:]', Punctuation),

            include('operators'),

            include('expressions'),

            include('whitespace'),

            (r'\(', Punctuation, 'in-()'),

            (r'\[', Punctuation, 'in-[]'),

            (r'\{', Punctuation, '#push'),

            (r'\}', Punctuation, '#pop'),

        ],



        'comments': [

            (r'//', Comment.Single, 'single-comments'),

            (r'/\*', Comment.Multiline, 'multiline-comments'),

        ],

        'single-comments': [

            (r'.*$', Comment.Single, '#pop'),

        ],

        'multiline-comments': [

            (r'/\*', Comment.Multiline, 'multiline-comments'),

            (r'\*/', Comment.Multiline, '#pop'),

            (r'[^/*]+', Comment.Multiline),

            (r'[/*]', Comment.Multiline)

        ],



        'strings': [

            # TODO: highlight escape sequences

            (r"'(?:\\[bfnrt\"'\\]|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8}|[^\\'])*'", String),

            (r'"(?:\\[bfnrt\'"\\]|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8}|[^\\"])*"', String),

        ],



        'keywords': word_list(cypher_keywords, Keyword),

        'pseudo-keywords': word_list(cypher_pseudo_keywords, Keyword),



        'escape-commands': [(r'^\s*!.*$', Comment.Single)],



        'labels': [

            (r'(:)(\s*)(`(?:``|[^`])+`)', bygroups(Punctuation, Whitespace, Name.Label)),

            (r'(:)(\s*)([A-Za-z_][0-9A-Za-z_]*)', bygroups(Punctuation, Whitespace, Name.Label)),

        ],



        'operators': (word_list(cypher_operator_words, Operator) +

                      symbol_list(cypher_operator_symbols, Operator)),



        'expressions': [

            include('procedures'),

            include('functions'),

            include('constants'),

            include('aliases'),

            include('variables'),

            include('parameters'),

            include('numbers'),

        ],

        'procedures': [

            (r'(CALL)(\s+)([A-Za-z_][0-9A-Za-z_\.]*)', bygroups(Keyword, Whitespace, Name.Function)),

        ],

        'functions': [

            (r'([A-Za-z_][0-9A-Za-z_\.]*)(\s*)(\()', bygroups(Name.Function, Whitespace, Punctuation), "in-()"),

        ],

        'aliases': [

            (r'(AS)(\s+)(`(?:``|[^`])+`)', bygroups(Keyword, Whitespace, Name.Variable)),

            (r'(AS)(\s+)([A-Za-z_][0-9A-Za-z_]*)', bygroups(Keyword, Whitespace, Name.Variable)),

        ],

        'variables': [

            (r'`(?:``|[^`])+`', Name.Variable),

            (r'[A-Za-z_][0-9A-Za-z_]*', Name.Variable),

        ],

        'parameters': [

            (r'(\$)(`(?:``|[^`])+`)', bygroups(Punctuation, Name.Variable.Global)),

            (r'(\$)([A-Za-z_][0-9A-Za-z_]*)', bygroups(Punctuation, Name.Variable.Global)),

        ],

        'constants': word_list(cypher_constants, Name.Constant),

        'numbers': [

            (r'[0-9]*\.[0-9]*(e[+-]?[0-9]+)?', Number.Float),

            (r'[0-9]+e[+-]?[0-9]+', Number.Float),

            (r'[0-9]+', Number.Integer),

        ],



        'whitespace': [

            (r'\s+', Whitespace),

        ],



    }



    def get_statements(self, text):

        """ Split the text into statements delimited by semicolons and

        yield each statement in turn. Yielded statements are stripped

        of both leading and trailing whitespace. Empty statements are

        skipped.

        """

        fragments = []

        for index, token_type, value in self.get_tokens_unprocessed(text):

            if token_type == Punctuation and value == ";":

                statement = "".join(fragments).strip()

                fragments[:] = ()

                if statement:

                    yield statement

            else:

                fragments.append(value)

        statement = "".join(fragments).strip()

        if statement:

            yield statement

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





__all__ = [

    "cypher_escape",

    "cypher_repr",

    "cypher_str",

]



from py2neo.cypher.encoding import CypherEncoder

from py2neo.internal.compat import string_types, unicode_types





def cypher_escape(identifier, **kwargs):

    """ Return a Cypher identifier, with escaping if required.



    Simple Cypher identifiers, which just contain alphanumerics

    and underscores, can be represented as-is in expressions.

    Any which contain more esoteric characters, such as spaces

    or punctuation, must be escaped in backticks. Backticks

    themselves are escaped by doubling.



    ::



        >>> cypher_escape("simple_identifier")

        'simple_identifier'

        >>> cypher_escape("identifier with spaces")

        '`identifier with spaces`'

        >>> cypher_escape("identifier with `backticks`")

        '`identifier with ``backticks```'



    Identifiers are used in Cypher to denote named values, labels,

    relationship types and property keys. This function will typically

    be used to construct dynamic Cypher queries in places where

    parameters cannot be used.



        >>> "MATCH (a:{label}) RETURN id(a)".format(label=cypher_escape("Employee of the Month"))

        'MATCH (a:`Employee of the Month`) RETURN id(a)'



    :param identifier: any non-empty string

    """

    if not isinstance(identifier, string_types):

        raise TypeError(type(identifier).__name__)

    encoder = CypherEncoder(**kwargs)

    return encoder.encode_key(identifier)





def cypher_repr(value, **kwargs):

    """ Return the Cypher representation of a value.



    This function attempts to convert the supplied value into a Cypher

    literal form, as used in expressions.



    """

    encoder = CypherEncoder(**kwargs)

    return encoder.encode_value(value)





def cypher_str(value, **kwargs):

    """ Convert a Cypher value to a Python Unicode string.



    This function converts the supplied value into a string form, as

    used for human-readable output. This is generally identical to

    :meth:`.cypher_repr` except for with string values, which are

    returned as-is, instead of being enclosed in quotes with certain

    characters escaped.



    """

    if isinstance(value, unicode_types):

        return value

    elif isinstance(value, string_types):

        return value.decode(kwargs.get("encoding", "utf-8"))

    else:

        return cypher_repr(value, **kwargs)

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from py2neo.ogm import GraphObject, Property, RelatedTo, RelatedFrom





class Movie(GraphObject):

    __primarykey__ = "title"



    title = Property()

    tagline = Property()

    released = Property()



    actors = RelatedFrom("Person", "ACTED_IN")

    directors = RelatedFrom("Person", "DIRECTED")

    producers = RelatedFrom("Person", "PRODUCED")

    writers = RelatedFrom("Person", "WROTE")

    reviewers = RelatedFrom("Person", "REVIEWED")



    def __lt__(self, other):

        return self.title < other.title





class Person(GraphObject):

    __primarykey__ = "name"



    name = Property()

    born = Property()



    acted_in = RelatedTo(Movie)

    directed = RelatedTo(Movie)

    produced = RelatedTo(Movie)

    wrote = RelatedTo(Movie)

    reviewed = RelatedTo(Movie)



    def __lt__(self, other):

        return self.name < other.name

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from os import getenv

from os.path import dirname, join as path_join



from flask import Flask, render_template, redirect, request



from py2neo import Graph



from py2neo.demo.movies.model import Movie, Person





app = Flask(__name__)

home = dirname(__file__)

static = path_join(home, "static")





# Set up a link to the local graph database.

graph = Graph(password=getenv("NEO4J_PASSWORD"))





@app.route("/")

def get_index():

    """ Index page.

    """

    return render_template("index.html")





@app.route("/person/")

def get_person_list():

    """ List of all people.

    """

    return render_template("person_list.html", people=Person.match(graph).order_by("_.name"))





@app.route("/person/<name>")

def get_person(name):

    """ Page with details for a specific person.

    """

    person = Person.match(graph, name).first()

    movies = [(movie.title, "Actor") for movie in person.acted_in] + \

             [(movie.title, "Director") for movie in person.directed]

    return render_template("person.html", person=person, movies=movies)





@app.route("/movie/")

def get_movie_list():

    """ List of all movies.

    """

    return render_template("movie_list.html", movies=Movie.match(graph).order_by("_.title"))





@app.route("/movie/<title>")

def get_movie(title):

    """ Page with details for a specific movie.

    """

    return render_template("movie.html", movie=Movie.match(graph, title).first())





@app.route("/movie/review", methods=["POST"])

def post_movie_review():

    """ Capture review and redirect to movie page.

    """

    with graph.begin() as tx:

        reviewer = Person.match(graph, request.values["name"]).first()

        if reviewer is None:

            reviewer = Person()

            reviewer.name = request.values["name"]

            tx.create(reviewer)

        movie = Movie.match(graph, request.values["title"]).first()

        movie.reviewers.add(reviewer, summary=request.values["summary"], rating=request.values["rating"])

        tx.push(movie)

    return redirect("/movie/%s" % movie.title)

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





"""

Low-level graph data storage classes.

"""





from collections import namedtuple

from functools import reduce

from operator import and_ as and_operator

from threading import RLock

from uuid import uuid4



from py2neo.data import PropertyDict, Record

from py2neo.internal.collections import iter_items

from py2neo.internal.compat import Sequence, Set





NodeEntry = namedtuple("NodeEntry", ["labels", "properties"])

RelationshipEntry = namedtuple("RelationshipEntry", ["type", "nodes", "properties"])





def property_record(iterable=()):

    """ Convert a dictionary-like iterable into a :class:`.Record`

    by sorting keys and dropping all values that are :const:`.None`.

    """

    return Record(sorted((key, value) for key, value in iter_items(iterable) if value is not None))





class ReactiveSet(set):

    """ A :class:`set` that can trigger callbacks for each element added

    or removed.

    """



    def __init__(self, iterable=(), on_add=None, on_remove=None):

        self._on_add = on_add

        self._on_remove = on_remove

        elements = set(iterable)

        set.__init__(self, elements)

        if callable(self._on_add):

            self._on_add(*elements)



    def __ior__(self, other):

        elements = other - self

        set.__ior__(self, other)

        if callable(self._on_add):

            self._on_add(*elements)

        return self



    def __iand__(self, other):

        elements = self ^ other

        set.__iand__(self, other)

        if callable(self._on_remove):

            self._on_remove(*elements)

        return self



    def __isub__(self, other):

        elements = self & other

        set.__isub__(self, other)

        if callable(self._on_remove):

            self._on_remove(*elements)

        return self



    def __ixor__(self, other):

        added = other - self

        removed = self & other

        set.__ixor__(self, other)

        if callable(self._on_add):

            self._on_add(*added)

        if callable(self._on_remove):

            self._on_remove(*removed)

        return self



    def add(self, element):

        """ Add an element to the set.



        :triggers: `on_add`

        """

        if element not in self:

            set.add(self, element)

            if callable(self._on_add):

                self._on_add(element)



    def remove(self, element):

        """ Remove an element from the set.



        :triggers: `on_remove`

        """

        set.remove(self, element)

        if callable(self._on_remove):

            self._on_remove(element)



    def discard(self, element):

        """ Discard an element from the set.



        :triggers: `on_remove`

        """

        if element in self:

            set.discard(self, element)

            if callable(self._on_remove):

                self._on_remove(element)



    def pop(self):

        """ Remove an arbitrary element from the set.



        :triggers: `on_remove`

        """

        element = set.pop(self)

        if callable(self._on_remove):

            self._on_remove(element)

        return element



    def clear(self):

        """ Remove all elements from the set.



        :triggers: `on_remove`

        """

        elements = set(self)

        set.clear(self)

        if callable(self._on_remove):

            self._on_remove(*elements)





class GraphStore(object):

    """ Low-level container for graph data.



    Internally, this object consists of five stores: two primary and three secondary.

    """



    # (a:Person {name: 'Alice'})-[r:KNOWS {since: 1999}]->(b:Person {name: 'Bob')



    # Node detail indexed by key.

    # This is a primary store.

    #

    # _nodes = {

    #     <node_key>: (<labels>, <properties>),

    #     "a": ({"Person"}, {"name": "Alice"}),

    #     "b": ({"Person"}, {"name": "Bob"}),

    # }

    #

    _nodes = None



    # Relationship detail indexed by key.

    # This is a primary store.

    #

    # _relationships = {

    #     <relationship_key>: (<type>, <nodes>, <properties>),

    #     "r": ("KNOWS", ("a", "b"), {"since": 1999}),

    # }

    #

    _relationships = None



    # Nodes indexed by label.

    # This is a secondary store.

    #

    # _nodes_by_label = {

    #     <label>: {<node_key>, <node_key>, ...}

    #     "Person": {"a", "b"},

    # }

    #

    _nodes_by_label = None



    # Relationships indexed by type.

    # This is a secondary store.

    #

    # {

    #     <type>: {<relationship_key>, <relationship_key>, ...},

    #     "KNOWS": {"r"},

    # }

    #

    _relationships_by_type = None



    # Relationships indexed by node.

    # This is a secondary store.

    #

    # {

    #     <node_key>: {(<relationship_key>, <index>), (<relationship_key>, <index>), ...},

    #     "a": {("r", 0)},

    #     "b": {("r", -1)},

    # }

    #

    _relationships_by_node = None



    @classmethod

    def build(cls, nodes=None, relationships=None):

        return cls(GraphStore(nodes, relationships))



    @classmethod

    def new_node_key(cls):

        return uuid4()



    @classmethod

    def new_relationship_key(cls):

        return uuid4()



    def __init__(self,

                 nodes=None,

                 relationships=None,

                 nodes_by_label=None,

                 relationships_by_type=None,

                 relationships_by_node=None):

        self._nodes = nodes or {}

        self._relationships = relationships or {}

        if nodes_by_label is None:

            self._build_nodes_by_label()

        else:

            self._nodes_by_label = nodes_by_label

        if relationships_by_type is None:

            self._build_relationships_by_type()

        else:

            self._relationships_by_type = relationships_by_type

        if relationships_by_node is None:

            self._build_relationships_by_node()

        else:

            self._relationships_by_node = relationships_by_node



    def is_mutable(self):

        raise NotImplementedError()



    def __eq__(self, other):

        if isinstance(other, self.__class__):

            return self._nodes == other._nodes and self._relationships == other._relationships

        else:

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        value = 0

        for node in self._nodes:

            value ^= hash(node)

        for relationship in self._relationships:

            value ^= hash(relationship)

        return value



    def _build_nodes_by_label(self):

        data = {}

        for node, (labels, _) in self._nodes.items():

            for label in labels:

                data.setdefault(label, set()).add(node)

        self._nodes_by_label = data



    def _build_relationships_by_type(self):

        data = {}

        for r_id, (r_type, _, _) in self._relationships.items():

            data.setdefault(r_type, set()).add(r_id)

        self._relationships_by_type = data



    def _build_relationships_by_node(self):

        data = {}

        for r_id, (_, n_ids, _) in self._relationships.items():

            for n_index, n_id in enumerate_nodes(n_ids):

                data.setdefault(n_id, set()).add((r_id, n_index))

        self._relationships_by_node = data



    def node_count(self, *n_labels):

        """ Count and return the number of nodes in this store.



        :param n_labels: count only nodes with all these labels

        :return: number of nodes

        """

        if not n_labels:

            return len(self._nodes)

        elif len(n_labels) == 1:

            return len(self._nodes_by_label.get(n_labels[0], ()))

        else:

            return sum(1 for _ in self.nodes(*n_labels))



    def nodes(self, *n_labels):

        """ Return an iterator over the node keys in this store,

        optionally filtered by label.

        """

        if n_labels:

            n_ids = ()

            n_id_sets = []

            for n_label in set(n_labels):

                try:

                    n_id_sets.append(self._nodes_by_label[n_label])

                except KeyError:

                    break

            else:

                n_ids = reduce(and_operator, n_id_sets)

        else:

            n_ids = self._nodes.keys()

        for n_id in n_ids:

            yield n_id



    def node_labels(self, n_id=None):

        """ Return the set of labels in this store or those for a specific node.

        """

        if n_id is None:

            return frozenset(self._nodes_by_label.keys())

        else:

            try:

                node_entry = self._nodes[n_id]

            except KeyError:

                return None

            else:

                return node_entry.labels



    def node_properties(self, n_id):

        try:

            node_entry = self._nodes[n_id]

        except KeyError:

            return None

        else:

            return node_entry.properties



    def relationship_count(self, r_type=None, n_ids=()):

        """ Count relationships filtered by type and endpoint.

        """

        if r_type is None and not n_ids:

            return len(self._relationships)

        elif not n_ids:

            return len(self._relationships_by_type.get(r_type, ()))

        else:

            return sum(1 for _ in self.relationships(r_type, n_ids))



    def relationships(self, r_type=None, n_ids=()):

        """ Match relationships filtered by type and endpoint.



        :param r_type:

        :param n_ids:

        :return:

        """

        if r_type is None:

            r_sets = []

        else:

            r_sets = [self._relationships_by_type.get(r_type, frozenset())]

        if not n_ids or (hasattr(n_ids, "__iter__") and all(n_id is None for n_id in n_ids)):

            pass

        elif isinstance(n_ids, Sequence):

            for n_index, n_id in enumerate_nodes(n_ids):

                if n_id is not None:

                    r_sets.append({r_id for r_id, i in self._relationships_by_node.get(n_id, ())

                                   if i == n_index})

        elif isinstance(n_ids, Set):

            for n_id in n_ids:

                if n_id is not None:

                    r_sets.append({r_id for r_id, i in self._relationships_by_node.get(n_id, ())})

        else:

            raise TypeError("Nodes must be supplied as a Sequence or a Set")

        if r_sets:

            return iter(reduce(and_operator, r_sets))

        else:

            return iter(self._relationships)



    def relationship_nodes(self, r_id):

        try:

            relationship_entry = self._relationships[r_id]

        except KeyError:

            return None

        else:

            return relationship_entry.nodes



    def relationship_properties(self, r_id):

        try:

            relationship_entry = self._relationships[r_id]

        except KeyError:

            return None

        else:

            return relationship_entry.properties



    def relationship_type(self, r_id):

        try:

            relationship_entry = self._relationships[r_id]

        except KeyError:

            return None

        else:

            return relationship_entry.type



    def relationship_types(self):

        """ Return the set of relationship types in this store.

        """

        return frozenset(self._relationships_by_type.keys())





class FrozenGraphStore(GraphStore):



    @classmethod

    def node_entry(cls, entry):

        labels, properties = entry

        return NodeEntry(frozenset(labels), property_record(properties))



    @classmethod

    def relationship_entry(cls, entry):

        type_, nodes, properties = entry

        return RelationshipEntry(type_, tuple(nodes), property_record(properties))



    def __init__(self, graph_store=None):

        if graph_store is None:

            super(FrozenGraphStore, self).__init__()

        elif isinstance(graph_store, FrozenGraphStore):

            super(FrozenGraphStore, self).__init__(nodes=graph_store._nodes,

                                                   relationships=graph_store._relationships,

                                                   nodes_by_label=graph_store._nodes_by_label,

                                                   relationships_by_type=graph_store._relationships_by_type,

                                                   relationships_by_node=graph_store._relationships_by_node)

        elif isinstance(graph_store, GraphStore):

            super(FrozenGraphStore, self).__init__()

            self._nodes.update((key, self.node_entry(entry))

                               for key, entry in graph_store._nodes.items())

            self._nodes_by_label.update((label, frozenset(nodes))

                                        for label, nodes in graph_store._nodes_by_label.items())

            self._relationships.update((key, self.relationship_entry(entry))

                                       for key, entry in graph_store._relationships.items())

            self._relationships_by_type.update((type_, frozenset(relationships))

                                               for type_, relationships in graph_store._relationships_by_type.items())

            self._relationships_by_node.update((node, frozenset(relationships))

                                               for node, relationships in graph_store._relationships_by_node.items())

        else:

            raise TypeError("Argument is not a graph store")



    def is_mutable(self):

        return False





class MutableGraphStore(GraphStore):



    def node_entry(self, key, entry):



        def add_labels(*labels_):

            for label in labels_:

                self._nodes_by_label.setdefault(label, set()).add(key)



        def remove_labels(*labels_):

            for label in labels_:

                try:

                    self._nodes_by_label[label].discard(key)

                except KeyError:

                    pass



        labels, properties = entry

        return NodeEntry(ReactiveSet(labels, on_add=add_labels, on_remove=remove_labels), PropertyDict(properties))



    @classmethod

    def relationship_entry(cls, entry):

        type_, nodes, properties = entry

        return RelationshipEntry(type_, tuple(nodes), PropertyDict(properties))



    def __init__(self, graph_store=None):

        super(MutableGraphStore, self).__init__()

        self._lock = RLock()

        if graph_store is not None:

            self.update(graph_store)



    def is_mutable(self):

        return True



    def _update_nodes(self, nodes):

        self._nodes.update((key, self.node_entry(key, entry)) for key, entry in nodes.items())



    def _update_relationships(self, relationships):

        self._relationships.update((key, self.relationship_entry(entry)) for key, entry in relationships.items())



    def _update_nodes_by_label(self, labels):

        for label, nodes in labels.items():

            self._nodes_by_label.setdefault(label, set()).update(nodes)



    def _update_relationships_by_type(self, relationships_by_type):

        for type_, relationships in relationships_by_type.items():

            self._relationships_by_type.setdefault(type_, set()).update(relationships)



    def _update_relationships_by_node(self, relationships_by_node):

        for n_id, entry in relationships_by_node.items():

            self._relationships_by_node.setdefault(n_id, set()).update(entry)



    def update(self, graph_store):

        if isinstance(graph_store, GraphStore):

            with self._lock:

                self._update_nodes(graph_store._nodes)

                self._update_relationships(graph_store._relationships)

                self._update_nodes_by_label(graph_store._nodes_by_label)

                self._update_relationships_by_type(graph_store._relationships_by_type)

                self._update_relationships_by_node(graph_store._relationships_by_node)

        else:

            raise TypeError("Argument is not a graph store")



    def add_nodes(self, entries):

        n_ids = []

        nodes = {}

        nodes_by_label = {}

        for entry in entries:

            n_id = self.new_node_key()

            mutable_entry = self.node_entry(n_id, entry)

            nodes[n_id] = mutable_entry

            for label in mutable_entry.labels:

                nodes_by_label.setdefault(label, set()).add(n_id)

            n_ids.append(n_id)

        with self._lock:

            self._update_nodes(nodes)

            self._update_nodes_by_label(nodes_by_label)

        return n_ids



    def remove_nodes(self, n_ids):

        with self._lock:

            for n_id in list(n_ids):

                # Remove from _nodes

                try:

                    n_labels, n_properties = self._nodes[n_id]

                except KeyError:

                    continue

                else:

                    del self._nodes[n_id]

                # Remove from _nodes_by_label

                for n_label in n_labels:

                    discard_value(self._nodes_by_label, n_label, n_id)

                # Remove relationships

                try:

                    self.remove_relationships(r_id for r_id, _ in self._relationships_by_node[n_id])

                except KeyError:

                    pass



    def add_relationships(self, entries):

        r_ids = []

        with self._lock:

            for r_type, n_ids, r_properties in entries:

                r_id = self.new_relationship_key()

                mutable_entry = self.relationship_entry((r_type, n_ids, r_properties))

                self._relationships[r_id] = mutable_entry

                self._relationships_by_type.setdefault(r_type, set()).add(r_id)

                for n_index, n_id in enumerate_nodes(n_ids):

                    self._relationships_by_node.setdefault(n_id, set()).add((r_id, n_index))

                r_ids.append(r_id)

        return r_ids



    def remove_relationships(self, r_ids):

        with self._lock:

            for r_id in list(r_ids):

                # Remove from _relationships

                try:

                    r_type, n_ids, r_properties = self._relationships[r_id]

                except KeyError:

                    continue

                else:

                    del self._relationships[r_id]

                # Remove from _relationships_by_type

                discard_value(self._relationships_by_type, r_type, r_id)

                # Remove from _relationships_by_node

                for n_index, n_id in enumerate_nodes(n_ids):

                    discard_value(self._relationships_by_node, n_id, (r_id, n_index))





def enumerate_nodes(iterable):

    try:

        size = len(iterable)

    except TypeError:

        iterable = list(iterable)

        size = len(iterable)

    last = size - 1

    for i, item in enumerate(iterable):

        yield -1 if i == last else i, item





def discard_value(collection, key, value):

    """ Discard an element from a value set.



    For a `collection` that maps `key` to {`value1`, `value2`, ...}, discard

    a specific `value` from the value set and drop the entire entry if the

    set becomes empty.

    """

    try:

        values = collection[key]

    except KeyError:

        pass

    else:

        values.discard(value)

        if not values:

            del collection[key]

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright (c) 2002-2019 "Neo4j,"

# Neo4j Sweden AB [http://neo4j.com]

#

# This file is part of Neo4j.

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





"""

This module defines spatial data types.

"""





from neobolt.packstream import Structure





__all__ = [

    "Point",

    "CartesianPoint",

    "WGS84Point",

]





# SRID to subclass mappings

__srid_table = {}





class Point(tuple):

    """ A point within a geometric space. This type is generally used

    via its subclasses and should not be instantiated directly unless

    there is no subclass defined for the required SRID.

    """



    srid = None



    def __new__(cls, iterable):

        return tuple.__new__(cls, iterable)



    def __repr__(self):

        return "POINT(%s)" % " ".join(map(str, self))



    def __eq__(self, other):

        try:

            return type(self) is type(other) and tuple(self) == tuple(other)

        except (AttributeError, TypeError):

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        return hash(type(self)) ^ hash(tuple(self))





def __point_subclass(name, fields, srid_map):

    """ Dynamically create a Point subclass.

    """



    def srid(self):

        try:

            return srid_map[len(self)]

        except KeyError:

            return None



    attributes = {"srid": property(srid)}



    for index, subclass_field in enumerate(fields):



        def accessor(self, i=index, f=subclass_field):

            try:

                return self[i]

            except IndexError:

                raise AttributeError(f)



        for field_alias in {subclass_field, "xyz"[index]}:

            attributes[field_alias] = property(accessor)



    cls = type(name, (Point,), attributes)



    for dim, srid in srid_map.items():

        __srid_table[srid] = (cls, dim)



    return cls





# Point subclass definitions

CartesianPoint = __point_subclass("CartesianPoint", ["x", "y", "z"], {2: 7203, 3: 9157})

WGS84Point = __point_subclass("WGS84Point", ["longitude", "latitude", "height"], {2: 4326, 3: 4979})





def hydrate_point(srid, *coordinates):

    """ Create a new instance of a Point subclass from a raw

    set of fields. The subclass chosen is determined by the

    given SRID; a ValueError will be raised if no such

    subclass can be found.

    """

    try:

        point_class, dim = __srid_table[srid]

    except KeyError:

        point = Point(coordinates)

        point.srid = srid

        return point

    else:

        if len(coordinates) != dim:

            raise ValueError("SRID %d requires %d coordinates (%d provided)" % (srid, dim, len(coordinates)))

        return point_class(coordinates)





def dehydrate_point(value):

    """ Dehydrator for Point data.



    :param value:

    :type value: Point

    :return:

    """

    dim = len(value)

    if dim == 2:

        return Structure(b"X", value.srid, *value)

    elif dim == 3:

        return Structure(b"Y", value.srid, *value)

    else:

        raise ValueError("Cannot dehydrate Point with %d dimensions" % dim)





__hydration_functions = {

    b"X": hydrate_point,

    b"Y": hydrate_point,

}



__dehydration_functions = {

    Point: dehydrate_point,

}

__dehydration_functions.update({cls: dehydrate_point for cls in Point.__subclasses__()})





def hydration_functions():

    return __hydration_functions





def dehydration_functions():

    return __dehydration_functions

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright (c) 2002-2019 "Neo4j,"

# Neo4j Sweden AB [http://neo4j.com]

#

# This file is part of Neo4j.

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import division





"""

This module defines temporal data types.

"""



from datetime import date, time, datetime, timedelta



from neotime import Duration, Date, Time, DateTime

from pytz import FixedOffset, timezone, utc



from neobolt.packstream import Structure





UNIX_EPOCH_DATE = Date(1970, 1, 1)

UNIX_EPOCH_DATE_ORDINAL = UNIX_EPOCH_DATE.to_ordinal()

UNIX_EPOCH_DATETIME_UTC = DateTime(1970, 1, 1, 0, 0, 0, utc)





def hydrate_date(days):

    """ Hydrator for `Date` values.



    :param days:

    :return: Date

    """

    return Date.from_ordinal(UNIX_EPOCH_DATE_ORDINAL + days)





def dehydrate_date(value):

    """ Dehydrator for `date` values.



    :param value:

    :type value: Date

    :return:

    """

    return Structure(b"D", value.toordinal() - UNIX_EPOCH_DATE.toordinal())





def hydrate_time(nanoseconds, tz=None):

    """ Hydrator for `Time` and `LocalTime` values.



    :param nanoseconds:

    :param tz:

    :return: Time

    """

    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))

    minutes, seconds = map(int, divmod(seconds, 60))

    hours, minutes = map(int, divmod(minutes, 60))

    seconds = (1000000000 * seconds + nanoseconds) / 1000000000

    t = Time(hours, minutes, seconds)

    if tz is None:

        return t

    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)

    zone = FixedOffset(tz_offset_minutes)

    return zone.localize(t)





def dehydrate_time(value):

    """ Dehydrator for `time` values.



    :param value:

    :type value: Time

    :return:

    """

    if isinstance(value, Time):

        nanoseconds = int(value.ticks * 1000000000)

    elif isinstance(value, time):

        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +

                       1000000000 * value.second + 1000 * value.microsecond)

    else:

        raise TypeError("Value must be a neotime.Time or a datetime.time")

    if value.tzinfo:

        return Structure(b"T", nanoseconds, value.tzinfo.utcoffset(value).seconds)

    else:

        return Structure(b"t", nanoseconds)





def hydrate_datetime(seconds, nanoseconds, tz=None):

    """ Hydrator for `DateTime` and `LocalDateTime` values.



    :param seconds:

    :param nanoseconds:

    :param tz:

    :return: datetime

    """

    minutes, seconds = map(int, divmod(seconds, 60))

    hours, minutes = map(int, divmod(minutes, 60))

    days, hours = map(int, divmod(hours, 24))

    seconds = (1000000000 * seconds + nanoseconds) / 1000000000

    t = DateTime.combine(Date.from_ordinal(UNIX_EPOCH_DATE_ORDINAL + days), Time(hours, minutes, seconds))

    if tz is None:

        return t

    if isinstance(tz, int):

        tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)

        zone = FixedOffset(tz_offset_minutes)

    else:

        zone = timezone(tz)

    return zone.localize(t)





def dehydrate_datetime(value):

    """ Dehydrator for `datetime` values.



    :param value:

    :type value: datetime

    :return:

    """



    def seconds_and_nanoseconds(dt):

        if isinstance(dt, datetime):

            dt = DateTime.from_native(dt)

        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)

        t = dt.to_clock_time() - zone_epoch.to_clock_time()

        return t.seconds, t.nanoseconds



    tz = value.tzinfo

    if tz is None:

        # without time zone

        value = utc.localize(value)

        seconds, nanoseconds = seconds_and_nanoseconds(value)

        return Structure(b"d", seconds, nanoseconds)

    elif hasattr(tz, "zone") and tz.zone:

        # with named time zone

        seconds, nanoseconds = seconds_and_nanoseconds(value)

        return Structure(b"f", seconds, nanoseconds, tz.zone)

    else:

        # with time offset

        seconds, nanoseconds = seconds_and_nanoseconds(value)

        return Structure(b"F", seconds, nanoseconds, tz.utcoffset(value).seconds)





def hydrate_duration(months, days, seconds, nanoseconds):

    """ Hydrator for `Duration` values.



    :param months:

    :param days:

    :param seconds:

    :param nanoseconds:

    :return: `duration` namedtuple

    """

    return Duration(months=months, days=days, seconds=seconds, nanoseconds=nanoseconds)





def dehydrate_duration(value):

    """ Dehydrator for `duration` values.



    :param value:

    :type value: Duration

    :return:

    """

    return Structure(b"E", value.months, value.days, value.seconds, int(1000000000 * value.subseconds))





def dehydrate_timedelta(value):

    """ Dehydrator for `timedelta` values.



    :param value:

    :type value: timedelta

    :return:

    """

    months = 0

    days = value.days

    seconds = value.seconds

    nanoseconds = 1000 * value.microseconds

    return Structure(b"E", months, days, seconds, nanoseconds)





__hydration_functions = {

    b"D": hydrate_date,

    b"T": hydrate_time,         # time zone offset

    b"t": hydrate_time,         # no time zone

    b"F": hydrate_datetime,     # time zone offset

    b"f": hydrate_datetime,     # time zone name

    b"d": hydrate_datetime,     # no time zone

    b"E": hydrate_duration,

}



# TODO: re-add built-in types

__dehydration_functions = {

    Date: dehydrate_date,

    date: dehydrate_date,

    Time: dehydrate_time,

    time: dehydrate_time,

    DateTime: dehydrate_datetime,

    datetime: dehydrate_datetime,

    Duration: dehydrate_duration,

    timedelta: dehydrate_timedelta,

}





def hydration_functions():

    return __hydration_functions





def dehydration_functions():

    return __dehydration_functions

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import absolute_import



from collections import deque, namedtuple

from json import loads as json_loads



from neobolt.packstream import Structure



from py2neo.internal.compat import Sequence, Mapping, integer_types, string_types

from py2neo.internal.hydration.spatial import (

    hydration_functions as spatial_hydration_functions,

    dehydration_functions as spatial_dehydration_functions,

)

from py2neo.internal.hydration.temporal import (

    hydration_functions as temporal_hydration_functions,

    dehydration_functions as temporal_dehydration_functions,

)

from py2neo.matching import RelationshipMatcher





INT64_LO = -(2 ** 63)

INT64_HI = 2 ** 63 - 1





def uri_to_id(uri):

    """ Utility function to convert entity URIs into numeric identifiers.

    """

    _, _, identity = uri.rpartition("/")

    return int(identity)





class CypherResult(object):

    """ Buffer for a result from a Cypher query.

    """



    def __init__(self, metadata=None, on_more=None, on_done=None):

        self._on_more = on_more

        self._on_done = on_done

        self._records = deque()

        self._metadata = metadata or {}

        self._done = False



    def append_records(self, records):

        self._records.extend(tuple(record) for record in records)



    def update_metadata(self, metadata):

        self._metadata.update(metadata)



    def done(self):

        if callable(self._on_done):

            self._on_done()

        self._done = True



    @property

    def _keys(self):

        return self._metadata.get("fields")



    def keys(self):

        while not self._keys and not self._done and callable(self._on_more):

            self._on_more()

        return self._keys



    def buffer(self):

        while not self._done:

            if callable(self._on_more):

                self._on_more()



    def summary(self):

        from py2neo.database import CypherSummary

        self.buffer()

        return CypherSummary(**self._metadata)



    def plan(self):

        from py2neo.database import CypherPlan

        self.buffer()

        if "plan" in self._metadata:

            return CypherPlan(**self._metadata["plan"])

        elif "profile" in self._metadata:

            return CypherPlan(**self._metadata["profile"])

        else:

            return None



    def stats(self):

        from py2neo.database import CypherStats

        self.buffer()

        return CypherStats(**self._metadata.get("stats", {}))



    def fetch(self):

        from py2neo.data import Record

        if self._records:

            return Record(zip(self.keys(), self._records.popleft()))

        elif self._done:

            return None

        else:

            while not self._records and not self._done:

                if callable(self._on_more):

                    self._on_more()

            try:

                return Record(zip(self.keys(), self._records.popleft()))

            except IndexError:

                return None





class Hydrator(object):



    def __init__(self, graph):

        self.graph = graph



    def hydrate(self, values):

        raise NotImplementedError()



    def dehydrate(self, values):

        raise NotImplementedError()



    def hydrate_node(self, instance, identity, labels=None, properties=None):

        if instance is None:



            def instance_constructor():

                from py2neo.data import Node

                new_instance = Node()

                new_instance.graph = self.graph

                new_instance.identity = identity

                new_instance._stale.update({"labels", "properties"})

                return new_instance



            instance = self.graph.node_cache.update(identity, instance_constructor)

        else:

            instance.graph = self.graph

            instance.identity = identity

            self.graph.node_cache.update(identity, instance)



        if properties is not None:

            instance._stale.discard("properties")

            instance.clear()

            instance.update(properties)



        if labels is not None:

            instance._stale.discard("labels")

            instance._remote_labels = frozenset(labels)

            instance.clear_labels()

            instance.update_labels(labels)



        return instance



    def hydrate_relationship(self, instance, identity, start, end, type=None, properties=None):



        if instance is None:



            def instance_constructor():

                from py2neo.data import Relationship

                if properties is None:

                    new_instance = Relationship(self.hydrate_node(None, start), type,

                                                self.hydrate_node(None, end))

                    new_instance._stale.add("properties")

                else:

                    new_instance = Relationship(self.hydrate_node(None, start), type,

                                                self.hydrate_node(None, end), **properties)

                new_instance.graph = self.graph

                new_instance.identity = identity

                return new_instance



            instance = self.graph.relationship_cache.update(identity, instance_constructor)

        else:

            instance.graph = self.graph

            instance.identity = identity

            self.hydrate_node(instance.start_node, start)

            self.hydrate_node(instance.end_node, end)

            instance._type = type

            if properties is None:

                instance._stale.add("properties")

            else:

                instance.clear()

                instance.update(properties)

            self.graph.relationship_cache.update(identity, instance)

        return instance





class HydrationError(Exception):



    pass





class PackStreamHydrator(Hydrator):



    unbound_relationship = namedtuple("UnboundRelationship", ["id", "type", "properties"])



    def __init__(self, version, graph, keys, entities=None):

        super(PackStreamHydrator, self).__init__(graph)

        self.version = version

        self.keys = keys

        self.entities = entities or {}

        self.hydration_functions = {}

        self.dehydration_functions = {}

        if self.version >= 2:

            self.hydration_functions.update(temporal_hydration_functions())

            self.hydration_functions.update(spatial_hydration_functions())

            self.dehydration_functions.update(temporal_dehydration_functions())

            self.dehydration_functions.update(spatial_dehydration_functions())



    def hydrate(self, values):

        """ Convert PackStream values into native values.

        """

        return tuple(self.hydrate_object(value, self.entities.get(self.keys[i]))

                     for i, value in enumerate(values))



    def hydrate_object(self, obj, inst=None):

        if isinstance(obj, Structure):

            tag = obj.tag

            fields = obj.fields

            if tag == b"N":

                return self.hydrate_node(inst, fields[0], fields[1], self.hydrate_object(fields[2]))

            elif tag == b"R":

                return self.hydrate_relationship(inst, fields[0], fields[1], fields[2], fields[3],

                                                 self.hydrate_object(fields[4]))

            elif tag == b"P":

                return self.hydrate_path(*fields)

            else:

                try:

                    f = self.hydration_functions[obj.tag]

                except KeyError:

                    # If we don't recognise the structure type, just return it as-is

                    return obj

                else:

                    return f(*map(self.hydrate_object, obj.fields))

        elif isinstance(obj, list):

            return list(map(self.hydrate_object, obj))

        elif isinstance(obj, dict):

            return {key: self.hydrate_object(value) for key, value in obj.items()}

        else:

            return obj



    def hydrate_path(self, nodes, relationships, sequence):

        from py2neo.data import Path

        nodes = [self.hydrate_node(None, n_id, n_label, self.hydrate_object(n_properties))

                 for n_id, n_label, n_properties in nodes]

        u_rels = []

        for r_id, r_type, r_properties in relationships:

            u_rel = self.unbound_relationship(r_id, r_type, self.hydrate_object(r_properties))

            u_rels.append(u_rel)

        last_node = nodes[0]

        steps = [last_node]

        for i, rel_index in enumerate(sequence[::2]):

            next_node = nodes[sequence[2 * i + 1]]

            if rel_index > 0:

                u_rel = u_rels[rel_index - 1]

                rel = self.hydrate_relationship(None, u_rel.id,

                                                last_node.identity, next_node.identity,

                                                u_rel.type, u_rel.properties)

            else:

                u_rel = u_rels[-rel_index - 1]

                rel = self.hydrate_relationship(None, u_rel.id,

                                                next_node.identity, last_node.identity,

                                                u_rel.type, u_rel.properties)

            steps.append(rel)

            # steps.append(next_node)

            last_node = next_node

        return Path(*steps)



    def dehydrate(self, data):

        """ Dehydrate to PackStream.

        """

        t = type(data)

        if t in self.dehydration_functions:

            f = self.dehydration_functions[t]

            return f(data)

        elif data is None or data is True or data is False or isinstance(data, float) or isinstance(data, string_types):

            return data

        elif isinstance(data, integer_types):

            if data < INT64_LO or data > INT64_HI:

                raise ValueError("Integers must be within the signed 64-bit range")

            return data

        elif isinstance(data, bytearray):

            return data

        elif isinstance(data, Mapping):

            d = {}

            for key in data:

                if not isinstance(key, string_types):

                    raise TypeError("Dictionary keys must be strings")

                d[key] = self.dehydrate(data[key])

            return d

        elif isinstance(data, Sequence):

            return list(map(self.dehydrate, data))

        else:

            raise TypeError("Neo4j does not support PackStream parameters of type %s" % type(data).__name__)





class JSONHydrator(Hydrator):



    unbound_relationship = namedtuple("UnboundRelationship", ["id", "type", "properties"])



    def __init__(self, version, graph, keys, entities=None):

        super(JSONHydrator, self).__init__(graph)

        self.version = version

        if self.version != "rest":

            raise ValueError("Unsupported JSON version %r" % self.version)

        self.keys = keys

        self.entities = entities or {}

        self.hydration_functions = {}



    @classmethod

    def json_to_packstream(cls, data):

        """ This converts from JSON format into PackStream prior to

        proper hydration. This code needs to die horribly in a freak

        yachting accident.

        """

        # TODO: other partial hydration

        if "self" in data:

            if "type" in data:

                return Structure(b"R",

                                 uri_to_id(data["self"]),

                                 uri_to_id(data["start"]),

                                 uri_to_id(data["end"]),

                                 data["type"],

                                 data["data"])

            else:

                return Structure(b"N",

                                 uri_to_id(data["self"]),

                                 data["metadata"]["labels"],

                                 data["data"])

        elif "nodes" in data and "relationships" in data:

            nodes = [Structure(b"N", i, None, None) for i in map(uri_to_id, data["nodes"])]

            relps = [Structure(b"r", i, None, None) for i in map(uri_to_id, data["relationships"])]

            seq = [i // 2 + 1 for i in range(2 * len(data["relationships"]))]

            for i, direction in enumerate(data["directions"]):

                if direction == "<-":

                    seq[2 * i] *= -1

            return Structure(b"P", nodes, relps, seq)

        else:

            # from warnings import warn

            # warn("Map literals returned over the Neo4j HTTP interface are ambiguous "

            #      "and may be unintentionally hydrated as graph objects")

            return data



    def hydrate(self, values):

        """ Convert JSON values into native values. This is the other half

        of the HTTP hydration process, and is basically a copy of the

        Bolt/PackStream hydration code. It needs to be combined with the

        code in `json_to_packstream` so that hydration is done in a single

        pass.

        """



        graph = self.graph

        entities = self.entities

        keys = self.keys



        def hydrate_object(obj, inst=None):

            from py2neo.data import Path

            if isinstance(obj, Structure):

                tag = obj.tag

                fields = obj.fields

                if tag == b"N":

                    return self.hydrate_node(inst, fields[0], fields[1], hydrate_object(fields[2]))

                elif tag == b"R":

                    return self.hydrate_relationship(inst, fields[0],

                                                     fields[1], fields[2],

                                                     fields[3], hydrate_object(fields[4]))

                elif tag == b"P":

                    # Herein lies a dirty hack to retrieve missing relationship

                    # detail for paths received over HTTP.

                    nodes = [hydrate_object(node) for node in fields[0]]

                    u_rels = []

                    typeless_u_rel_ids = []

                    for r in fields[1]:

                        u_rel = self.unbound_relationship(*map(hydrate_object, r))

                        assert u_rel.type is None

                        typeless_u_rel_ids.append(u_rel.id)

                        u_rels.append(u_rel)

                    if typeless_u_rel_ids:

                        r_dict = {r.identity: r for r in RelationshipMatcher(graph).get(typeless_u_rel_ids)}

                        for i, u_rel in enumerate(u_rels):

                            if u_rel.type is None:

                                u_rels[i] = self.unbound_relationship(

                                    u_rel.id,

                                    type(r_dict[u_rel.id]).__name__,

                                    u_rel.properties

                                )

                    sequence = fields[2]

                    last_node = nodes[0]

                    steps = [last_node]

                    for i, rel_index in enumerate(sequence[::2]):

                        next_node = nodes[sequence[2 * i + 1]]

                        if rel_index > 0:

                            u_rel = u_rels[rel_index - 1]

                            rel = self.hydrate_relationship(None, u_rel.id,

                                                            last_node.identity, next_node.identity,

                                                            u_rel.type, u_rel.properties)

                        else:

                            u_rel = u_rels[-rel_index - 1]

                            rel = self.hydrate_relationship(None, u_rel.id,

                                                            next_node.identity, last_node.identity,

                                                            u_rel.type, u_rel.properties)

                        steps.append(rel)

                        # steps.append(next_node)

                        last_node = next_node

                    return Path(*steps)

                else:

                    try:

                        f = self.hydration_functions[obj.tag]

                    except KeyError:

                        # If we don't recognise the structure type, just return it as-is

                        return obj

                    else:

                        return f(*map(hydrate_object, obj.fields))

            elif isinstance(obj, list):

                return list(map(hydrate_object, obj))

            elif isinstance(obj, dict):

                return {key: hydrate_object(value) for key, value in obj.items()}

            else:

                return obj



        return tuple(hydrate_object(value, entities.get(keys[i])) for i, value in enumerate(values))



    def hydrate_result(self, data, index=0):

        data = json_loads(data, object_hook=self.json_to_packstream)

        if data.get("errors"):

            raise HydrationError(*data["errors"])

        return data["results"][index]



    def dehydrate(self, data):

        """ Dehydrate to JSON.

        """

        if data is None or data is True or data is False or isinstance(data, float) or isinstance(data, string_types):

            return data

        elif isinstance(data, integer_types):

            if data < INT64_LO or data > INT64_HI:

                raise ValueError("Integers must be within the signed 64-bit range")

            return data

        elif isinstance(data, bytearray):

            return list(data)

        elif isinstance(data, Mapping):

            d = {}

            for key in data:

                if not isinstance(key, string_types):

                    raise TypeError("Dictionary keys must be strings")

                d[key] = self.dehydrate(data[key])

            return d

        elif isinstance(data, Sequence):

            return list(map(self.dehydrate, data))

        else:

            raise TypeError("Neo4j does not support JSON parameters of type %s" % type(data).__name__)

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from threading import Lock, local

from weakref import WeakValueDictionary





class ThreadLocalEntityCache(local):



    def __init__(self):

        self.lock = Lock()

        self._dict = WeakValueDictionary()



    def __contains__(self, key):

        return key in self._dict



    def __getitem__(self, key):

        return self._dict[key]



    def get(self, key, default=None):

        return self._dict.get(key, default)



    def clear(self):

        self._dict.clear()



    def keys(self):

        return self._dict.keys()



    def update(self, key, value):

        """ Extract, insert or remove a value for a given key.

        """

        with self.lock:

            if value is None:

                # remove

                try:

                    del self._dict[key]

                except KeyError:

                    pass

                else:

                    return None

            elif callable(value):

                try:

                    # extract

                    return self._dict[key]

                except KeyError:

                    # construct and insert

                    new_value = value()

                    self._dict[key] = new_value

                    return new_value

            else:

                # insert or replace

                self._dict[key] = value

                return value

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import absolute_import



from itertools import cycle, islice



from py2neo.internal.compat import Set, bytes_types, string_types





def is_collection(obj):

    """ Returns true for any iterable which is not a string or byte sequence.

    """

    if isinstance(obj, bytes_types) or isinstance(obj, string_types):

        return False

    try:

        iter(obj)

    except TypeError:

        return False

    else:

        return True





def iter_items(iterable):

    """ Iterate through all items (key-value pairs) within an iterable

    dictionary-like object. If the object has a `keys` method, this is

    used along with `__getitem__` to yield each pair in turn. If no

    `keys` method exists, each iterable element is assumed to be a

    2-tuple of key and value.

    """

    if hasattr(iterable, "keys"):

        for key in iterable.keys():

            yield key, iterable[key]

    else:

        for key, value in iterable:

            yield key, value





class SetView(Set):



    def __init__(self, collection):

        self.__collection = collection



    def __eq__(self, other):

        return frozenset(self) == frozenset(other)



    def __ne__(self, other):

        return not self.__eq__(other)



    def __len__(self):

        return len(self.__collection)



    def __iter__(self):

        return iter(self.__collection)



    def __contains__(self, element):

        return element in self.__collection



    def difference(self, other):

        cls = self.__class__

        return cls(frozenset(self).difference(frozenset(other)))

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import absolute_import



try:

    from configparser import SafeConfigParser

except ImportError:

    from ConfigParser import SafeConfigParser



try:

    from collections.abc import Sequence, Set, Mapping

except ImportError:

    from collections import Sequence, Set, Mapping



try:

    from urllib.parse import urlparse, urlsplit

except ImportError:

    from urlparse import urlparse, urlsplit



try:

    from urllib.request import urlretrieve

except ImportError:

    from urllib import urlretrieve



from io import StringIO

import os

from socket import error as SocketError

from sys import version_info

from warnings import warn





if version_info >= (3,):

    # Python 3



    atomic_types = (bool, bytearray, bytes, float, int, str)

    bytes_types = (bytearray, bytes)

    integer_types = (int,)

    list_types = (list, map)

    numeric_types = (int, float)

    string_types = (bytes, str)

    unicode_types = (str,)

    utf8_types = ()



    long = int

    uchr = chr



    def bstr(s, encoding="utf-8"):

        """ Convert a value to a byte string, held in a Python `bytearray` object.

        """

        if isinstance(s, bytearray):

            return s

        elif isinstance(s, bytes):

            return bytearray(s)

        elif isinstance(s, str):

            return bytearray(s.encode(encoding=encoding))

        else:

            try:

                return bytearray(s.__bytes__())

            except AttributeError:

                return bytearray(str(s).encode(encoding=encoding))



    def ustr(s, encoding="utf-8"):

        """ Convert a value to a Unicode string, held in a Python `str` object.

        """

        if isinstance(s, str):

            return s

        elif isinstance(s, (bytes, bytearray)):

            return s.decode(encoding=encoding)

        else:

            try:

                return s.__str__()

            except AttributeError:

                return str(s, encoding=encoding)



    def xstr(s, encoding="utf-8"):

        """ Convert argument to string type returned by __str__.

        """

        if isinstance(s, str):

            return s

        elif isinstance(s, bytes):

            return s.decode(encoding)

        else:

            return str(s)



    class PropertiesParser(SafeConfigParser):



        def read_properties(self, filename, section=None):

            if not section:

                basename = os.path.basename(filename)

                if basename.endswith(".properties"):

                    section = basename[:-11]

                else:

                    section = basename

            with open(filename) as f:

                data = f.read()

            self.read_string("[%s]\n%s" % (section, data), filename)



else:

    # Python 2



    atomic_types = (bool, bytearray, float, int, long, str, unicode)

    bytes_types = (bytearray,)

    integer_types = (int, long)

    list_types = (list,)

    numeric_types = (int, long, float)

    string_types = (str, unicode)

    unicode_types = (unicode,)

    utf8_types = (str,)



    long = long

    uchr = unichr



    def bstr(s, encoding="utf-8"):

        """ Convert a value to byte string, held in a Python `bytearray` object.

        """

        if isinstance(s, bytearray):

            return s

        elif isinstance(s, bytes):

            return bytearray(s)

        elif isinstance(s, unicode):

            return bytearray(s.encode(encoding=encoding))

        else:

            try:

                return bytearray(s.__bytes__())

            except AttributeError:

                return bytearray(unicode(s).encode(encoding=encoding))



    def ustr(s, encoding="utf-8"):

        """ Convert a value to a Unicode string, held in a Python `unicode` object.

        """

        if isinstance(s, unicode):

            return s

        elif isinstance(s, (bytes, bytearray)):

            return s.decode(encoding=encoding)

        else:

            try:

                return s.__unicode__()

            except AttributeError:

                return str(s).decode(encoding=encoding)



    def xstr(s, encoding="utf-8"):

        """ Convert argument to string type returned by __str__.

        """

        if isinstance(s, str):

            return s

        else:

            return unicode(s).encode(encoding)



    class PropertiesParser(SafeConfigParser):



        def read_properties(self, filename, section=None):

            if not section:

                basename = os.path.basename(filename)

                if basename.endswith(".properties"):

                    section = basename[:-11]

                else:

                    section = basename

            data = StringIO()

            data.write("[%s]\n" % section)

            with codecs.open(filename, encoding="utf-8") as f:

                data.write(f.read())

            data.seek(0, os.SEEK_SET)

            self.readfp(data)





def deprecated(message):

    """ Decorator for deprecating functions and methods.



    ::



        @deprecated("'foo' has been deprecated in favour of 'bar'")

        def foo(x):

            pass



    """

    def f__(f):

        def f_(*args, **kwargs):

            warn(message, category=DeprecationWarning, stacklevel=2)

            return f(*args, **kwargs)

        f_.__name__ = f.__name__

        f_.__doc__ = f.__doc__

        f_.__dict__.update(f.__dict__)

        return f_

    return f__





def metaclass(mcs):

    def _metaclass(cls):

        attributes = cls.__dict__.copy()

        slots = attributes.get("__slots__")

        if slots is not None:

            if isinstance(slots, str):

                slots = [slots]

            for slot in slots:

                attributes.pop(slot)

        attributes.pop("__dict__", None)

        attributes.pop("__weakref__", None)

        return mcs(cls.__name__, cls.__bases__, attributes)

    return _metaclass

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import absolute_import



from collections import OrderedDict

from hashlib import new as hashlib_new

from json import dumps as json_dumps, loads as json_loads



from certifi import where

from neobolt.direct import connect, ConnectionPool

from urllib3 import HTTPConnectionPool, HTTPSConnectionPool, make_headers



from py2neo.internal.compat import bstr, urlsplit

from py2neo.internal.hydration import CypherResult, JSONHydrator, PackStreamHydrator, HydrationError

from py2neo.meta import NEO4J_URI, NEO4J_AUTH, NEO4J_USER_AGENT, NEO4J_SECURE, NEO4J_VERIFIED, \

    bolt_user_agent, http_user_agent





DEFAULT_SCHEME = "bolt"

DEFAULT_SECURE = False

DEFAULT_VERIFIED = False

DEFAULT_USER = "neo4j"

DEFAULT_PASSWORD = "password"

DEFAULT_HOST = "localhost"

DEFAULT_BOLT_PORT = 7687

DEFAULT_HTTP_PORT = 7474

DEFAULT_HTTPS_PORT = 7473



DEFAULT_MAX_CONNECTIONS = 40





def coalesce(*values):

    """ Utility function to return the first non-null value from a

    sequence of values.

    """

    for value in values:

        if value is not None:

            return value

    return None





def get_connection_data(uri=None, **settings):

    """ Generate a dictionary of connection data for an optional URI plus

    additional connection settings.



    :param uri:

    :param settings:

    :return:

    """

    data = {

        "host": None,

        "password": None,

        "port": None,

        "scheme": None,

        "secure": None,

        "verified": None,

        "user": None,

        "user_agent": None,

    }

    # apply uri

    uri = coalesce(uri, NEO4J_URI)

    if uri is not None:

        parsed = urlsplit(uri)

        if parsed.scheme is not None:

            data["scheme"] = parsed.scheme

            if data["scheme"] in ["https"]:

                data["secure"] = True

            elif data["scheme"] in ["http"]:

                data["secure"] = False

        data["user"] = coalesce(parsed.username, data["user"])

        data["password"] = coalesce(parsed.password, data["password"])

        data["host"] = coalesce(parsed.hostname, data["host"])

        data["port"] = coalesce(parsed.port, data["port"])

    # apply auth (this can override `uri`)

    if "auth" in settings and settings["auth"] is not None:

        data["user"], data["password"] = settings["auth"]

    elif NEO4J_AUTH is not None:

        data["user"], _, data["password"] = NEO4J_AUTH.partition(":")

    # apply components (these can override `uri` and `auth`)

    data["user_agent"] = coalesce(settings.get("user_agent"), NEO4J_USER_AGENT, data["user_agent"])

    data["secure"] = coalesce(settings.get("secure"), data["secure"], NEO4J_SECURE)

    data["verified"] = coalesce(settings.get("verified"), data["verified"], NEO4J_VERIFIED)

    data["scheme"] = coalesce(settings.get("scheme"), data["scheme"])

    data["user"] = coalesce(settings.get("user"), data["user"])

    data["password"] = coalesce(settings.get("password"), data["password"])

    data["host"] = coalesce(settings.get("host"), data["host"])

    data["port"] = coalesce(settings.get("port"), data["port"])

    # apply correct scheme for security

    if data["secure"] is True and data["scheme"] == "http":

        data["scheme"] = "https"

    if data["secure"] is False and data["scheme"] == "https":

        data["scheme"] = "http"

    # apply default port for scheme

    if data["scheme"] and not data["port"]:

        if data["scheme"] == "http":

            data["port"] = DEFAULT_HTTP_PORT

        elif data["scheme"] == "https":

            data["port"] = DEFAULT_HTTPS_PORT

        elif data["scheme"] in ["bolt"]:

            data["port"] = DEFAULT_BOLT_PORT

    # apply other defaults

    if not data["user_agent"]:

        data["user_agent"] = http_user_agent() if data["scheme"] in ["http", "https"] else bolt_user_agent()

    if data["secure"] is None:

        data["secure"] = DEFAULT_SECURE

    if data["verified"] is None:

        data["verified"] = DEFAULT_VERIFIED

    if not data["scheme"]:

        data["scheme"] = DEFAULT_SCHEME

        if data["scheme"] == "http":

            data["secure"] = False

            data["verified"] = False

        if data["scheme"] == "https":

            data["secure"] = True

            data["verified"] = True

    if not data["user"]:

        data["user"] = DEFAULT_USER

    if not data["password"]:

        data["password"] = DEFAULT_PASSWORD

    if not data["host"]:

        data["host"] = DEFAULT_HOST

    if not data["port"]:

        data["port"] = DEFAULT_BOLT_PORT

    # apply composites

    data["auth"] = (data["user"], data["password"])

    data["uri"] = "%s://%s:%s" % (data["scheme"], data["host"], data["port"])

    h = hashlib_new("md5")

    for key in sorted(data):

        h.update(bstr(data[key]))

    data["hash"] = h.hexdigest()

    return data





class Connector(object):



    scheme = NotImplemented



    pool = None

    transactions = set()



    @classmethod

    def walk_subclasses(cls):

        subclasses = cls.__subclasses__()

        for subclass in subclasses:

            yield subclass

            for c in subclass.walk_subclasses():

                yield c



    def __new__(cls, uri, **settings):

        cx_data = get_connection_data(uri, **settings)

        for subclass in cls.walk_subclasses():

            if subclass.scheme == cx_data["scheme"]:

                inst = object.__new__(subclass)

                inst.open(cx_data, **settings)

                inst.connection_data = cx_data

                return inst

        raise ValueError("Unsupported scheme %r" % cx_data["scheme"])



    @property

    def server_agent(self):

        raise NotImplementedError()



    def open(self, cx_data, **_):

        raise NotImplementedError()



    def close(self):

        raise NotImplementedError()



    def run(self, statement, parameters=None, tx=None, graph=None, keys=None, entities=None):

        raise NotImplementedError()



    def is_valid_transaction(self, tx):

        return tx is not None and tx in self.transactions



    def _assert_valid_tx(self, tx):

        from py2neo.database import TransactionError

        if tx is None:

            raise TransactionError("No transaction")

        if tx not in self.transactions:

            raise TransactionError("Invalid transaction")



    def begin(self):

        raise NotImplementedError()



    def commit(self, tx):

        raise NotImplementedError()



    def rollback(self, tx):

        raise NotImplementedError()



    def sync(self, tx):

        raise NotImplementedError()





class BoltConnector(Connector):



    scheme = "bolt"



    @property

    def server_agent(self):

        cx = self.pool.acquire()

        try:

            return cx.server.agent

        finally:

            self.pool.release(cx)



    def open(self, cx_data, max_connections=None, **_):



        def connector(address_, **kwargs):

            return connect(address_, auth=cx_data["auth"],

                           encrypted=cx_data["secure"], **kwargs)



        address = (cx_data["host"], cx_data["port"])

        max_connections = max_connections or DEFAULT_MAX_CONNECTIONS

        self.pool = ConnectionPool(

            connector=connector,

            address=address,

            max_connection_pool_size=max_connections,

        )



    def close(self):

        self.pool.close()



    def _run_1(self, statement, parameters, graph, keys, entities):

        cx = self.pool.acquire()

        hydrator = PackStreamHydrator(version=cx.protocol_version, graph=graph, keys=keys, entities=entities)

        dehydrated_parameters = hydrator.dehydrate(parameters)

        result = CypherResult(on_more=cx.fetch, on_done=lambda: self.pool.release(cx))

        result.update_metadata({"connection": self.connection_data})



        def update_metadata_with_keys(metadata):

            result.update_metadata(metadata)

            hydrator.keys = result.keys()



        cx.run(statement, dehydrated_parameters or {}, on_success=update_metadata_with_keys, on_failure=self._fail)

        cx.pull_all(on_records=lambda records: result.append_records(map(hydrator.hydrate, records)),

                    on_success=result.update_metadata, on_failure=self._fail, on_summary=result.done)

        cx.send()

        cx.fetch()

        return result



    def _run_in_tx(self, statement, parameters, tx, graph, keys, entities):

        self._assert_valid_tx(tx)



        def fetch():

            tx.fetch()



        def fail(metadata):

            self.transactions.remove(tx)

            self.pool.release(tx)

            self._fail(metadata)



        hydrator = PackStreamHydrator(version=tx.protocol_version, graph=graph, keys=keys, entities=entities)

        dehydrated_parameters = hydrator.dehydrate(parameters)

        result = CypherResult(on_more=fetch)

        result.update_metadata({"connection": self.connection_data})



        def update_metadata_with_keys(metadata):

            result.update_metadata(metadata)

            hydrator.keys = result.keys()



        tx.run(statement, dehydrated_parameters or {}, on_success=update_metadata_with_keys, on_failure=fail)

        tx.pull_all(on_records=lambda records: result.append_records(map(hydrator.hydrate, records)),

                    on_success=result.update_metadata, on_failure=fail, on_summary=result.done)

        tx.send()

        result.keys()   # force receipt of RUN summary, to detect any errors

        return result



    @classmethod

    def _fail(cls, metadata):

        from py2neo.database import GraphError

        raise GraphError.hydrate(metadata)



    def run(self, statement, parameters=None, tx=None, graph=None, keys=None, entities=None):

        if tx is None:

            return self._run_1(statement, parameters, graph, keys, entities)

        else:

            return self._run_in_tx(statement, parameters, tx, graph, keys, entities)



    def begin(self):

        tx = self.pool.acquire()

        tx.begin()

        self.transactions.add(tx)

        return tx



    def commit(self, tx):

        self._assert_valid_tx(tx)

        self.transactions.remove(tx)

        tx.commit()

        tx.sync()

        self.pool.release(tx)



    def rollback(self, tx):

        self._assert_valid_tx(tx)

        self.transactions.remove(tx)

        tx.rollback()

        tx.sync()

        self.pool.release(tx)



    def sync(self, cx):

        cx.sync()





class HTTPConnector(Connector):



    scheme = "http"



    headers = None



    @property

    def server_agent(self):

        r = self.pool.request(method="GET",

                              url="/db/data/",

                              headers=dict(self.headers))

        return "Neo4j/{neo4j_version}".format(**json_loads(r.data.decode("utf-8")))



    def open(self, cx_data, max_connections=None, **_):

        self.pool = HTTPConnectionPool(

            host=cx_data["host"],

            port=cx_data["port"],

            maxsize=max_connections or DEFAULT_MAX_CONNECTIONS,

            block=True,

        )

        self.headers = make_headers(basic_auth=":".join(cx_data["auth"]))



    def close(self):

        self.pool.close()



    def _post(self, url, statement=None, parameters=None):

        if statement:

            statements = [

                OrderedDict([

                    ("statement", statement),

                    ("parameters", parameters or {}),

                    ("resultDataContents", ["REST"]),

                    ("includeStats", True),

                ])

            ]

        else:

            statements = []

        return self.pool.request(method="POST",

                                 url=url,

                                 headers=dict(self.headers, **{"Content-Type": "application/json"}),

                                 body=json_dumps({"statements": statements}))



    def _delete(self, url):

        return self.pool.request(method="DELETE",

                                 url=url,

                                 headers=dict(self.headers))



    def run(self, statement, parameters=None, tx=None, graph=None, keys=None, entities=None):

        hydrator = JSONHydrator(version="rest", graph=graph, keys=keys, entities=entities)

        r = self._post("/db/data/transaction/%s" % (tx or "commit"), statement, hydrator.dehydrate(parameters))

        assert r.status == 200  # TODO: other codes

        try:

            raw_result = hydrator.hydrate_result(r.data.decode("utf-8"))

        except HydrationError as e:

            from py2neo.database import GraphError  # TODO: breaks abstraction layers :(

            if tx is not None:

                self.transactions.remove(tx)

            raise GraphError.hydrate(e.args[0])

        else:

            result = CypherResult({

                "connection": self.connection_data,

                "fields": raw_result.get("columns"),

                "plan": raw_result.get("plan"),

                "stats": raw_result.get("stats"),

            })

            hydrator.keys = result.keys()

            result.append_records(hydrator.hydrate(record[hydrator.version]) for record in raw_result["data"])

            result.done()

            return result



    def begin(self):

        r = self._post("/db/data/transaction")

        if r.status == 201:

            location_path = urlsplit(r.headers["Location"]).path

            tx = location_path.rpartition("/")[-1]

            self.transactions.add(tx)

            return tx

        else:

            raise RuntimeError("Can't begin a new transaction")



    def commit(self, tx):

        self._assert_valid_tx(tx)

        self.transactions.remove(tx)

        self._post("/db/data/transaction/%s/commit" % tx)



    def rollback(self, tx):

        self._assert_valid_tx(tx)

        self.transactions.remove(tx)

        self._delete("/db/data/transaction/%s" % tx)



    def sync(self, tx):

        pass





class SecureHTTPConnector(HTTPConnector):



    scheme = "https"



    def open(self, cx_data):

        self.pool = HTTPSConnectionPool(host=cx_data["host"], port=cx_data["port"],

                                        cert_reqs="CERT_NONE", ca_certs=where())

        self.headers = make_headers(basic_auth=":".join(cx_data["auth"]))

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import absolute_import





__all__ = [

    "create_subgraph",

    "delete_subgraph",

    "merge_subgraph",

    "pull_subgraph",

    "push_subgraph",

    "separate_subgraph",

    "subgraph_exists",

]





from py2neo.cypher import cypher_escape





def _node_create_dict(nodes):

    """ Convert a set of :class:`.Node` objects into a dictionary of

    :class:`.Node` lists, keyed by frozenset(labels).



    :param nodes:

    :return: dict of frozenset(labels) to list(nodes)

    """

    d = {}

    for node in nodes:

        key = frozenset(node.labels)

        d.setdefault(key, []).append(node)

    return d





def _node_merge_dict(primary_label, primary_key, nodes):

    """ Convert a set of :class:`.Node` objects into a dictionary of

    :class:`.Node` lists, keyed by a 3-tuple of

    (primary_label, primary_key, frozenset(labels)).



    :param primary_label:

    :param primary_key:

    :param nodes:

    :return: dict of (p_label, p_key, frozenset(labels)) to list(nodes)

    """

    d = {}

    for node in nodes:

        p_label = getattr(node, "__primarylabel__", None) or primary_label

        p_key = getattr(node, "__primarykey__", None) or primary_key

        key = (p_label, p_key, frozenset(node.labels))

        d.setdefault(key, []).append(node)

    return d





def _rel_create_dict(relationships):

    """ Convert a set of :class:`.Relationship` objects into a dictionary

    of :class:`.Relationship` lists, keyed by type.



    :param relationships:

    :return:

    """

    d = {}

    for relationship in relationships:

        key = type(relationship).__name__

        d.setdefault(key, []).append(relationship)

    return d





def _create_nodes(tx, labels, data):

    assert isinstance(labels, frozenset)

    label_string = "".join(":" + cypher_escape(label) for label in sorted(labels))

    cypher = "UNWIND $x AS data CREATE (_%s) SET _ = data RETURN id(_)" % label_string

    for record in tx.run(cypher, x=data):

        yield record[0]





def _merge_nodes(tx, p_label, p_key, labels, data):

    """



    :param tx:

    :param p_label:

    :param p_key:

    :param labels:

    :param data: list of (p_value, properties)

    :return:

    """

    assert isinstance(labels, frozenset)

    label_string = ":".join(cypher_escape(label) for label in sorted(labels))

    cypher = "UNWIND $x AS data MERGE (_:%s {%s:data[0]}) SET _:%s SET _ = data[1] RETURN id(_)" % (

        cypher_escape(p_label), cypher_escape(p_key), label_string)

    for record in tx.run(cypher, x=data):

        yield record[0]





def _merge_relationships(tx, r_type, data):

    """



    :param tx:

    :param r_type:

    :param data: list of (a_id, b_id, properties)

    :return:

    """

    cypher = ("UNWIND $x AS data "

              "MATCH (a) WHERE id(a) = data[0] "

              "MATCH (b) WHERE id(b) = data[1] "

              "MERGE (a)-[_:%s]->(b) SET _ = data[2] RETURN id(_)" % cypher_escape(r_type))

    for record in tx.run(cypher, x=data):

        yield record[0]





def create_subgraph(tx, subgraph):

    """ Create new data in a remote :class:`.Graph` from a local

    :class:`.Subgraph`.



    :param tx:

    :param subgraph:

    :return:

    """

    graph = tx.graph

    for labels, nodes in _node_create_dict(n for n in subgraph.nodes if n.graph is None).items():

        identities = _create_nodes(tx, labels, list(map(dict, nodes)))

        for i, identity in enumerate(identities):

            node = nodes[i]

            node.graph = graph

            node.identity = identity

            node._remote_labels = labels

            graph.node_cache.update(identity, node)

    for r_type, relationships in _rel_create_dict(r for r in subgraph.relationships if r.graph is None).items():

        identities = _merge_relationships(tx, r_type, list(map(

            lambda r: [r.start_node.identity, r.end_node.identity, dict(r)], relationships)))

        for i, identity in enumerate(identities):

            relationship = relationships[i]

            relationship.graph = graph

            relationship.identity = identity

            graph.relationship_cache.update(identity, relationship)





def merge_subgraph(tx, subgraph, p_label, p_key):

    """ Merge data into a remote :class:`.Graph` from a local

    :class:`.Subgraph`.



    :param tx:

    :param subgraph:

    :param p_label:

    :param p_key:

    :return:

    """

    graph = tx.graph

    for (pl, pk, labels), nodes in _node_merge_dict(p_label, p_key, (n for n in subgraph.nodes if n.graph is None)).items():

        if pl is None or pk is None:

            raise ValueError("Primary label and primary key are required for MERGE operation")

        identities = _merge_nodes(tx, pl, pk, labels, list(map(lambda n: [n.get(pk), dict(n)], nodes)))

        for i, identity in enumerate(identities):

            node = nodes[i]

            node.graph = graph

            node.identity = identity

            node._remote_labels = labels

            graph.node_cache.update(identity, node)

    for r_type, relationships in _rel_create_dict(r for r in subgraph.relationships if r.graph is None).items():

        identities = _merge_relationships(tx, r_type, list(map(

            lambda r: [r.start_node.identity, r.end_node.identity, dict(r)], relationships)))

        for i, identity in enumerate(identities):

            relationship = relationships[i]

            relationship.graph = graph

            relationship.identity = identity

            graph.relationship_cache.update(identity, relationship)





def delete_subgraph(tx, subgraph):

    """ Delete data in a remote :class:`.Graph` based on a local

    :class:`.Subgraph`.



    :param tx:

    :param subgraph:

    :return:

    """

    graph = tx.graph

    node_identities = []

    for relationship in subgraph.relationships:

        if relationship.graph is graph:

            graph.relationship_cache.update(relationship.identity, None)

            relationship.graph = None

            relationship.identity = None

    for node in subgraph.nodes:

        if node.graph is graph:

            graph.node_cache.update(node.identity, None)

            node_identities.append(node.identity)

            node.graph = None

            node.identity = None

    list(tx.run("MATCH (_) WHERE id(_) IN $x DETACH DELETE _", x=node_identities))





def separate_subgraph(tx, subgraph):

    """ Delete relationships in a remote :class:`.Graph` based on a

    local :class:`.Subgraph`.



    :param tx:

    :param subgraph:

    :return:

    """

    graph = tx.graph

    relationship_identities = []

    for relationship in subgraph.relationships:

        if relationship.graph is graph:

            graph.relationship_cache.update(relationship.identity, None)

            relationship_identities.append(relationship.identity)

            relationship.graph = None

            relationship.identity = None

    list(tx.run("MATCH ()-[_]->() WHERE id(_) IN $x DELETE _", x=relationship_identities))





def pull_subgraph(tx, subgraph):

    """ Copy data from a remote :class:`.Graph` into a local

    :class:`.Subgraph`.



    :param tx:

    :param subgraph:

    :return:

    """

    graph = tx.graph

    nodes = {node: None for node in subgraph.nodes}

    relationships = list(subgraph.relationships)

    for node in nodes:

        if node.graph is graph:

            tx.entities.append({"_": node})

            cursor = tx.run("MATCH (_) WHERE id(_) = {x} RETURN _, labels(_)", x=node.identity)

            nodes[node] = cursor

    for relationship in relationships:

        if relationship.graph is graph:

            tx.entities.append({"_": relationship})

            list(tx.run("MATCH ()-[_]->() WHERE id(_) = {x} RETURN _", x=relationship.identity))

    for node, cursor in nodes.items():

        new_labels = cursor.evaluate(1)

        if new_labels:

            node._remote_labels = frozenset(new_labels)

            labels = node._labels

            labels.clear()

            labels.update(new_labels)





def push_subgraph(tx, subgraph):

    """ Copy data into a remote :class:`.Graph` from a local

    :class:`.Subgraph`.



    :param tx:

    :param subgraph:

    :return:

    """

    graph = tx.graph

    for node in subgraph.nodes:

        if node.graph is graph:

            clauses = ["MATCH (_) WHERE id(_) = {x}", "SET _ = {y}"]

            parameters = {"x": node.identity, "y": dict(node)}

            old_labels = node._remote_labels - node._labels

            if old_labels:

                clauses.append("REMOVE _:%s" % ":".join(map(cypher_escape, old_labels)))

            new_labels = node._labels - node._remote_labels

            if new_labels:

                clauses.append("SET _:%s" % ":".join(map(cypher_escape, new_labels)))

            tx.run("\n".join(clauses), parameters)

    for relationship in subgraph.relationships:

        if relationship.graph is graph:

            clauses = ["MATCH ()-[_]->() WHERE id(_) = {x}", "SET _ = {y}"]

            parameters = {"x": relationship.identity, "y": dict(relationship)}

            tx.run("\n".join(clauses), parameters)





def subgraph_exists(tx, subgraph):

    """ Determine whether one or more graph entities all exist within the

    database. Note that if any nodes or relationships in *subgraph* are not

    bound to remote counterparts, this method will return ``False``.



    :param tx:

    :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                   :class:`.Subgraph`

    :returns: ``True`` if all entities exist remotely, ``False`` otherwise

    """

    graph = tx.graph

    node_ids = set()

    relationship_ids = set()

    for i, node in enumerate(subgraph.nodes):

        if node.graph is graph:

            node_ids.add(node.identity)

        else:

            return False

    for i, relationship in enumerate(subgraph.relationships):

        if relationship.graph is graph:

            relationship_ids.add(relationship.identity)

        else:

            return False

    statement = ("OPTIONAL MATCH (a) WHERE id(a) IN {x} "

                 "OPTIONAL MATCH ()-[r]->() WHERE id(r) IN {y} "

                 "RETURN count(DISTINCT a) + count(DISTINCT r)")

    parameters = {"x": list(node_ids), "y": list(relationship_ids)}

    return tx.evaluate(statement, parameters) == len(node_ids) + len(relationship_ids)

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from functools import reduce

from operator import add

from re import findall





def html_escape(s):

    return (s.replace(u"&", u"&amp;")

             .replace(u"<", u"&lt;")

             .replace(u">", u"&gt;")

             .replace(u'"', u"&quot;")

             .replace(u"'", u"&#039;"))





def iter_words(s):

    if " " in s:

        for word in s.split():

            yield word

    elif "_" in s:

        for word in s.split("_"):

            yield word

    elif "-" in s:

        for word in s.split("-"):

            yield word

    elif s.isupper():

        yield s

    else:

        for word in findall(r"[A-Z]?[^A-Z]*", s):

            if word:

                yield word





class Words(object):



    def __init__(self, words):

        if isinstance(words, tuple):

            words = reduce(add, map(tuple, map(iter_words, words)), ())

        else:

            words = iter_words(words)

        self.words = tuple(word for word in words if word)



    def upper(self, separator=" "):

        return separator.join(word.upper() for word in self.words)



    def lower(self, separator=" "):

        return separator.join(word.lower() for word in self.words)



    def title(self):

        all_caps = all(word.isupper() for word in self.words)



        def title_word(word):

            if not word or (word.isupper() and not all_caps):

                return word

            else:

                return word[0].upper() + word[1:]



        return " ".join(map(title_word, self.words))



    def snake(self):

        return self.lower("_")



    def camel(self, upper_first=False):

        s = "".join(word[0].upper() + word[1:].lower() for word in self.words)

        if upper_first:

            return s

        else:

            return s[0].lower() + s[1:]

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from unicodedata import category





class Version(tuple):



    @classmethod

    def parse(cls, string):

        parts = []

        last_ch = None

        for ch in string:

            if last_ch is None:

                parts.append([ch])

            elif ch == ".":

                if last_ch in ".-":

                    parts[-1][-1] += "0"

                parts[-1].append("")

            elif ch == "-":

                if last_ch in ".-":

                    parts[-1][-1] += "0"

                parts.append([""])

            else:

                if last_ch not in ".-" and category(ch)[0] != category(last_ch)[0]:

                    parts.append([ch])

                else:

                    parts[-1][-1] += ch

            last_ch = ch

        for part in parts:

            for i, x in enumerate(part):

                try:

                    part[i] = int(x)

                except (ValueError, TypeError):

                    pass

            while len(part) > 1 and not part[-1]:

                part[:] = part[:-1]

        return cls(*map(tuple, parts))



    def __new__(cls, *parts):

        parts = list(parts)

        for i, part in enumerate(parts):

            if not isinstance(part, tuple):

                parts[i] = (part,)

        return super(Version, cls).__new__(cls, parts)



    def __repr__(self):

        return "%s%r" % (type(self).__name__, tuple(self))



    @property

    def primary(self):

        try:

            return self[0]

        except IndexError:

            return ()



    @property

    def major(self):

        try:

            return self.primary[0]

        except IndexError:

            return 0



    @property

    def minor(self):

        try:

            return self.primary[1]

        except IndexError:

            return 0



    @property

    def patch(self):

        try:

            return self.primary[2]

        except IndexError:

            return 0



    @property

    def major_minor(self):

        return self.major, self.minor



    @property

    def major_minor_patch(self):

        return self.major, self.minor, self.patch

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from functools import reduce

from io import StringIO

from itertools import chain

from operator import xor as xor_operator

from uuid import uuid4



from py2neo.cypher import cypher_repr, cypher_str

from py2neo.cypher.encoding import LabelSetView

from py2neo.internal.collections import is_collection, iter_items, SetView

from py2neo.internal.compat import Mapping, integer_types, numeric_types, string_types, ustr, xstr

from py2neo.internal.operations import create_subgraph, merge_subgraph, delete_subgraph, separate_subgraph, \

    pull_subgraph, push_subgraph, subgraph_exists

from py2neo.internal.text import html_escape





def walk(*walkables):

    """ Traverse over the arguments supplied, yielding the entities

    from each in turn.



    :arg walkables: sequence of walkable objects

    """

    if not walkables:

        return

    walkable = walkables[0]

    try:

        entities = walkable.__walk__()

    except AttributeError:

        raise TypeError("Object %r is not walkable" % walkable)

    for entity in entities:

        yield entity

    end_node = walkable.end_node

    for walkable in walkables[1:]:

        try:

            if end_node == walkable.start_node:

                entities = walkable.__walk__()

                end_node = walkable.end_node

            elif end_node == walkable.end_node:

                entities = reversed(list(walkable.__walk__()))

                end_node = walkable.start_node

            else:

                raise ValueError("Cannot append walkable %r "

                                 "to node %r" % (walkable, end_node))

        except AttributeError:

            raise TypeError("Object %r is not walkable" % walkable)

        for i, entity in enumerate(entities):

            if i > 0:

                yield entity





class Record(tuple, Mapping):

    """ A :class:`.Record` is an immutable ordered collection of key-value

    pairs. It is generally closer to a :class:`namedtuple` than to a

    :class:`OrderedDict` inasmuch as iteration of the collection will

    yield values rather than keys.

    """



    __keys = None



    def __new__(cls, iterable=()):

        keys = []

        values = []

        for key, value in iter_items(iterable):

            keys.append(key)

            values.append(value)

        inst = tuple.__new__(cls, values)

        inst.__keys = tuple(keys)

        return inst



    def __repr__(self):

        return "<%s %s>" % (self.__class__.__name__,

                            " ".join("%s=%r" % (field, self[i]) for i, field in enumerate(self.__keys)))



    def __eq__(self, other):

        return dict(self) == dict(other)



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        return reduce(xor_operator, map(hash, self.items()))



    def __getitem__(self, key):

        if isinstance(key, slice):

            keys = self.__keys[key]

            values = super(Record, self).__getitem__(key)

            return self.__class__(zip(keys, values))

        index = self.index(key)

        if 0 <= index < len(self):

            return super(Record, self).__getitem__(index)

        else:

            return None



    def __getslice__(self, start, stop):

        key = slice(start, stop)

        keys = self.__keys[key]

        values = tuple(self)[key]

        return self.__class__(zip(keys, values))



    def get(self, key, default=None):

        """ Obtain a single value from the record by index or key. If the

        specified item does not exist, the default value is returned.



        :param key: index or key

        :param default: default value to be returned if `key` does not exist

        :return: selected value

        """

        try:

            index = self.__keys.index(ustr(key))

        except ValueError:

            return default

        if 0 <= index < len(self):

            return super(Record, self).__getitem__(index)

        else:

            return default



    def index(self, key):

        """ Return the index of the given item.

        """

        if isinstance(key, integer_types):

            if 0 <= key < len(self.__keys):

                return key

            raise IndexError(key)

        elif isinstance(key, string_types):

            try:

                return self.__keys.index(key)

            except ValueError:

                raise KeyError(key)

        else:

            raise TypeError(key)



    def keys(self):

        """ Return the keys of the record.



        :return: list of key names

        """

        return list(self.__keys)



    def values(self, *keys):

        """ Return the values of the record, optionally filtering to

        include only certain values by index or key.



        :param keys: indexes or keys of the items to include; if none

                     are provided, all values will be included

        :return: list of values

        """

        if keys:

            d = []

            for key in keys:

                try:

                    i = self.index(key)

                except KeyError:

                    d.append(None)

                else:

                    d.append(self[i])

            return d

        return list(self)



    def items(self, *keys):

        """ Return the fields of the record as a list of key and value tuples



        :param keys: indexes or keys of the items to include; if none

                     are provided, all values will be included

        :return: list of (key, value) tuples

        """

        if keys:

            d = []

            for key in keys:

                try:

                    i = self.index(key)

                except KeyError:

                    d.append((key, None))

                else:

                    d.append((self.__keys[i], self[i]))

            return d

        return list((self.__keys[i], super(Record, self).__getitem__(i)) for i in range(len(self)))



    def data(self, *keys):

        """ Return the keys and values of this record as a dictionary,

        optionally including only certain values by index or key. Keys

        provided that do not exist within the record will be included

        but with a value of :py:const:`None`; indexes provided

        that are out of bounds will trigger an :exc:`IndexError`.



        :param keys: indexes or keys of the items to include; if none

                     are provided, all values will be included

        :return: dictionary of values, keyed by field name

        :raises: :exc:`IndexError` if an out-of-bounds index is specified

        """

        if keys:

            d = {}

            for key in keys:

                try:

                    i = self.index(key)

                except KeyError:

                    d[key] = None

                else:

                    d[self.__keys[i]] = self[i]

            return d

        return dict(self)



    def to_subgraph(self):

        """ Return a :class:`.Subgraph` containing the union of all the

        graph structures within this :class:`.Record`.



        :return: :class:`.Subgraph` object

        """

        s = None

        for value in self.values():

            if isinstance(value, Subgraph):

                if s is None:

                    s = value

                else:

                    s |= value

        return s





class PropertyDict(dict):

    """ Mutable key-value property store.



    A dictionary for property values that treats :const:`None`

    and missing values as semantically identical.



    PropertyDict instances can be created and used in a similar way

    to a standard dictionary. For example::



        >>> fruit = PropertyDict({"name": "banana", "colour": "yellow"})

        >>> fruit["name"]

        'banana'



    The key difference with a PropertyDict is in how it handles

    missing values. Instead of raising a :py:class:`KeyError`,

    attempts to access a missing value will simply return

    :py:const:`None` instead.



    These are the operations that the PropertyDict can support:



   .. describe:: len(d)



        Return the number of items in the PropertyDict `d`.



   .. describe:: d[key]



        Return the item of `d` with key `key`. Returns :py:const:`None`

        if key is not in the map.



    """



    def __init__(self, iterable=None, **kwargs):

        dict.__init__(self)

        self.update(iterable, **kwargs)



    def __eq__(self, other):

        return dict.__eq__(self, {key: value for key, value in other.items() if value is not None})



    def __ne__(self, other):

        return not self.__eq__(other)



    def __getitem__(self, key):

        return dict.get(self, key)



    def __setitem__(self, key, value):

        if value is None:

            try:

                dict.__delitem__(self, key)

            except KeyError:

                pass

        else:

            dict.__setitem__(self, key, value)



    def setdefault(self, key, default=None):

        if key in self:

            value = self[key]

        elif default is None:

            value = None

        else:

            value = dict.setdefault(self, key, default)

        return value



    def update(self, iterable=None, **kwargs):

        for key, value in dict(iterable or {}, **kwargs).items():

            self[key] = value





class Table(list):

    """ Immutable list of records.

    """



    def __init__(self, records, keys=None):

        super(Table, self).__init__(map(tuple, records))

        if keys is None:

            try:

                k = records.keys()

            except AttributeError:

                raise ValueError("Missing keys")

        else:

            k = list(map(ustr, keys))

        width = len(k)

        t = [set() for _ in range(width)]

        o = [False] * width

        for record in self:

            for i, value in enumerate(record):

                if value is None:

                    o[i] = True

                else:

                    t[i].add(type(value))

        f = []

        for i, _ in enumerate(k):

            f.append({

                "type": t[i].copy().pop() if len(t[i]) == 1 else tuple(t[i]),

                "numeric": all(t_ in numeric_types for t_ in t[i]),

                "optional": o[i],

            })

        self._keys = k

        self._fields = f



    def __repr__(self):

        s = StringIO()

        self.write(file=s, header=True)

        return s.getvalue()



    def _repr_html_(self):

        """ Return a string containing an HTML representation of this table.

        This method is used by Jupyter notebooks to display the table natively within a browser.

        Internally, this method calls :meth:`.write_html` with `header=True`, writing the output into an ``io.StringIO`` instance.

        """

        s = StringIO()

        self.write_html(file=s, header=True)

        return s.getvalue()



    def keys(self):

        """ Return a list of field names for this table.

        """

        return list(self._keys)



    def field(self, key):

        """ Return a dictionary of metadata for a given field.

        The metadata includes the following values:



        `type`

            Single class or tuple of classes representing the

            field values.



        `numeric`

            :const:`True` if all field values are of a numeric

            type, :const:`False` otherwise.



        `optional`

            :const:`True` if any field values are :const:`None`,

            :const:`False` otherwise.



        """

        if isinstance(key, integer_types):

            return self._fields[key]

        elif isinstance(key, string_types):

            try:

                index = self._keys.index(key)

            except ValueError:

                raise KeyError(key)

            else:

                return self._fields[index]

        else:

            raise TypeError(key)



    def _range(self, skip, limit):

        if skip is None:

            skip = 0

        if limit is None or skip + limit > len(self):

            return range(skip, len(self))

        else:

            return range(skip, skip + limit)



    def write(self, file=None, header=None, skip=None, limit=None, auto_align=True,

              padding=1, separator=u"|", newline=u"\r\n"):

        """ Write data to a human-readable ASCII art table.



        :param file: file-like object capable of receiving output

        :param header: boolean flag for addition of column headers

        :param skip: number of records to skip before beginning output

        :param limit: maximum number of records to include in output

        :param auto_align: if :const:`True`, right-justify numeric values

        :param padding: number of spaces to include between column separator and value

        :param separator: column separator character

        :param newline: newline character sequence

        :return: the number of records included in output

        """

        from click import secho



        space = u" " * padding

        widths = [1 if header else 0] * len(self._keys)



        def calc_widths(values, **_):

            strings = [cypher_str(value).splitlines(False) for value in values]

            for i, s in enumerate(strings):

                w = max(map(len, s)) if s else 0

                if w > widths[i]:

                    widths[i] = w



        def write_line(values, underline=u"", **styles):

            strings = [cypher_str(value).splitlines(False) for value in values]

            height = max(map(len, strings)) if strings else 1

            for y in range(height):

                line_text = u""

                underline_text = u""

                for x, _ in enumerate(values):

                    try:

                        text = strings[x][y]

                    except IndexError:

                        text = u""

                    if auto_align and self._fields[x]["numeric"]:

                        text = space + text.rjust(widths[x]) + space

                        u_text = underline * len(text)

                    else:

                        text = space + text.ljust(widths[x]) + space

                        u_text = underline * len(text)

                    if x > 0:

                        text = separator + text

                        u_text = separator + u_text

                    line_text += text

                    underline_text += u_text

                if underline:

                    line_text += newline + underline_text

                line_text += newline

                secho(line_text, file, nl=False, **styles)



        def apply(f):

            count = 0

            for count, index in enumerate(self._range(skip, limit), start=1):

                if count == 1 and header:

                    f(self.keys(), underline=u"-")

                f(self[index])

            return count



        apply(calc_widths)

        return apply(write_line)



    def write_html(self, file=None, header=None, skip=None, limit=None, auto_align=True):

        """ Write data to an HTML table.



        :param file: file-like object capable of receiving output

        :param header: boolean flag for addition of column headers

        :param skip: number of records to skip before beginning output

        :param limit: maximum number of records to include in output

        :param auto_align: if :const:`True`, right-justify numeric values

        :return: the number of records included in output

        """

        from click import echo



        def write_tr(values, tag):

            echo(u"<tr>", file, nl=False)

            for i, value in enumerate(values):

                if tag == "th":

                    template = u'<{}>{}</{}>'

                elif auto_align and self._fields[i]["numeric"]:

                    template = u'<{} style="text-align:right">{}</{}>'

                else:

                    template = u'<{} style="text-align:left">{}</{}>'

                echo(template.format(tag, html_escape(cypher_str(value)), tag), file, nl=False)

            echo(u"</tr>", file, nl=False)



        count = 0

        echo(u"<table>", file, nl=False)

        for count, index in enumerate(self._range(skip, limit), start=1):

            if count == 1 and header:

                write_tr(self.keys(), u"th")

            write_tr(self[index], u"td")

        echo(u"</table>", file, nl=False)

        return count



    def write_separated_values(self, separator, file=None, header=None, skip=None, limit=None,

                               newline=u"\r\n", quote=u"\""):

        """ Write data to a delimiter-separated file.



        :param separator: field separator character

        :param file: file-like object capable of receiving output

        :param header: boolean flag (or dictionary of ``click.secho`` styles) for addition of column headers

        :param skip: number of records to skip before beginning output

        :param limit: maximum number of records to include in output

        :param newline: newline character sequence

        :param quote: quote character

        :return: the number of records included in output

        """

        from click import secho



        escaped_quote = quote + quote

        quotable = separator + newline + quote

        header_styles = {}

        if header and isinstance(header, dict):

            header_styles.update(header)



        def write_value(value, **styles):

            if value is None:

                return

            if isinstance(value, string_types):

                value = ustr(value)

                if any(ch in value for ch in quotable):

                    value = quote + value.replace(quote, escaped_quote) + quote

            else:

                value = cypher_repr(value)

            secho(value, file, nl=False, **styles)



        def write_line(values, **styles):

            for i, value in enumerate(values):

                if i > 0:

                    secho(separator, file, nl=False, **styles)

                write_value(value, **styles)

            secho(newline, file, nl=False, **styles)



        def apply(f):

            count = 0

            for count, index in enumerate(self._range(skip, limit), start=1):

                if count == 1 and header:

                    f(self.keys(), underline=u"-", **header_styles)

                f(self[index])

            return count



        return apply(write_line)



    def write_csv(self, file=None, header=None, skip=None, limit=None):

        """ Write the data as RFC4180-compatible comma-separated values.

        This is a customised call to :meth:`.write_separated_values`.

        """

        return self.write_separated_values(u",", file, header, skip, limit)



    def write_tsv(self, file=None, header=None, skip=None, limit=None):

        """ Write the data as tab-separated values.

        This is a customised call to :meth:`.write_separated_values`.

        """

        return self.write_separated_values(u"\t", file, header, skip, limit)





class Subgraph(object):

    """ Arbitrary, unordered collection of nodes and relationships.

    """



    def __init__(self, nodes=None, relationships=None):

        self.__nodes = frozenset(nodes or [])

        self.__relationships = frozenset(relationships or [])

        self.__nodes |= frozenset(chain(*(r.nodes for r in self.__relationships)))

        if not self.__nodes:

            raise ValueError("Subgraphs must contain at least one node")



    # def __repr__(self):

    #     return "Subgraph({" + ", ".join(map(repr, self.nodes)) + "}, {" + ", ".join(map(repr, self.relationships)) + "})"



    def __eq__(self, other):

        try:

            return self.nodes == other.nodes and self.relationships == other.relationships

        except (AttributeError, TypeError):

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        value = 0

        for entity in self.__nodes:

            value ^= hash(entity)

        for entity in self.__relationships:

            value ^= hash(entity)

        return value



    def __len__(self):

        return len(self.__relationships)



    def __iter__(self):

        return iter(self.__relationships)



    def __bool__(self):

        return bool(self.__relationships)



    def __nonzero__(self):

        return bool(self.__relationships)



    def __or__(self, other):

        return Subgraph(set(self.nodes) | set(other.nodes), set(self.relationships) | set(other.relationships))



    def __and__(self, other):

        return Subgraph(set(self.nodes) & set(other.nodes), set(self.relationships) & set(other.relationships))



    def __sub__(self, other):

        r = set(self.relationships) - set(other.relationships)

        n = (set(self.nodes) - set(other.nodes)) | set().union(*(set(rel.nodes) for rel in r))

        return Subgraph(n, r)



    def __xor__(self, other):

        r = set(self.relationships) ^ set(other.relationships)

        n = (set(self.nodes) ^ set(other.nodes)) | set().union(*(set(rel.nodes) for rel in r))

        return Subgraph(n, r)



    def __db_create__(self, tx):

        create_subgraph(tx, self)



    def __db_delete__(self, tx):

        delete_subgraph(tx, self)



    def __db_exists__(self, tx):

        return subgraph_exists(tx, self)



    def __db_merge__(self, tx, primary_label=None, primary_key=None):

        merge_subgraph(tx, self, primary_label, primary_key)



    def __db_pull__(self, tx):

        pull_subgraph(tx, self)



    def __db_push__(self, tx):

        push_subgraph(tx, self)



    def __db_separate__(self, tx):

        separate_subgraph(tx, self)



    @property

    def graph(self):

        assert self.__nodes     # assume there is at least one node

        return set(self.__nodes).pop().graph



    @property

    def nodes(self):

        """ Set of all nodes.

        """

        return SetView(self.__nodes)



    @property

    def relationships(self):

        """ Set of all relationships.

        """

        return SetView(self.__relationships)



    @property

    def labels(self):

        """ Set of all node labels.

        """

        return frozenset(chain(*(node.labels for node in self.__nodes)))



    def types(self):

        """ Set of all relationship types.

        """

        return frozenset(type(rel).__name__ for rel in self.__relationships)



    def keys(self):

        """ Set of all property keys.

        """

        return (frozenset(chain(*(node.keys() for node in self.__nodes))) |

                frozenset(chain(*(rel.keys() for rel in self.__relationships))))





class Walkable(Subgraph):

    """ A subgraph with added traversal information.

    """



    def __init__(self, iterable):

        self.__sequence = tuple(iterable)

        Subgraph.__init__(self, self.__sequence[0::2], self.__sequence[1::2])



    def __repr__(self):

        return xstr(cypher_repr(self))



    def __eq__(self, other):

        try:

            other_walk = tuple(walk(other))

        except TypeError:

            return False

        else:

            return tuple(walk(self)) == other_walk



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        value = 0

        for item in self.__sequence:

            value ^= hash(item)

        return value



    def __len__(self):

        return (len(self.__sequence) - 1) // 2



    def __getitem__(self, index):

        if isinstance(index, slice):

            start, stop = index.start, index.stop

            if start is not None:

                if start < 0:

                    start += len(self)

                start *= 2

            if stop is not None:

                if stop < 0:

                    stop += len(self)

                stop = 2 * stop + 1

            return Walkable(self.__sequence[start:stop])

        elif index < 0:

            return self.__sequence[2 * index]

        else:

            return self.__sequence[2 * index + 1]



    def __iter__(self):

        for relationship in self.__sequence[1::2]:

            yield relationship



    def __add__(self, other):

        if other is None:

            return self

        return Walkable(walk(self, other))



    def __walk__(self):

        """ Traverse and yield all nodes and relationships in this

        object in order.

        """

        return iter(self.__sequence)



    @property

    def start_node(self):

        """ The first node encountered on a :func:`.walk` of this object.

        """

        return self.__sequence[0]



    @property

    def end_node(self):

        """ The last node encountered on a :func:`.walk` of this object.

        """

        return self.__sequence[-1]



    @property

    def nodes(self):

        """ The sequence of nodes over which a :func:`.walk` of this

        object will traverse.

        """

        return self.__sequence[0::2]



    @property

    def relationships(self):

        """ The sequence of relationships over which a :func:`.walk`

        of this object will traverse.

        """

        return self.__sequence[1::2]





class Entity(PropertyDict, Walkable):

    """ Base class for objects that can be optionally bound to a remote resource. This

    class is essentially a container for a :class:`.Resource` instance.

    """



    graph = None

    identity = None



    def __init__(self, iterable, properties):

        Walkable.__init__(self, iterable)

        PropertyDict.__init__(self, properties)

        uuid = str(uuid4())

        while "0" <= uuid[-7] <= "9":

            uuid = str(uuid4())

        self.__uuid__ = uuid



    def __repr__(self):

        return Walkable.__repr__(self)



    def __bool__(self):

        return len(self) > 0



    def __nonzero__(self):

        return len(self) > 0



    @property

    def __name__(self):

        name = None

        if name is None and "__name__" in self:

            name = self["__name__"]

        if name is None and "name" in self:

            name = self["name"]

        if name is None and self.identity is not None:

            name = u"_" + ustr(self.identity)

        return name or u""





class Node(Entity):

    """ A node is a fundamental unit of data storage within a property

    graph that may optionally be connected, via relationships, to

    other nodes.



    All positional arguments passed to the constructor are interpreted

    as labels and all keyword arguments as properties::



        >>> from py2neo import Node

        >>> a = Node("Person", name="Alice")



    """



    @classmethod

    def cast(cls, obj):

        """ Cast an arbitrary object to a :class:`Node`. This method

        takes its best guess on how to interpret the supplied object

        as a :class:`Node`.

        """

        if obj is None or isinstance(obj, Node):

            return obj



        def apply(x):

            if isinstance(x, dict):

                inst.update(x)

            elif is_collection(x):

                for item in x:

                    apply(item)

            elif isinstance(x, string_types):

                inst.add_label(ustr(x))

            else:

                raise TypeError("Cannot cast %s to Node" % obj.__class__.__name__)



        inst = Node()

        apply(obj)

        return inst



    def __init__(self, *labels, **properties):

        self._remote_labels = frozenset()

        self._labels = set(labels)

        Entity.__init__(self, (self,), properties)

        self._stale = set()



    def __eq__(self, other):

        if self is other:

            return True

        try:

            if any(x is None for x in [self.graph, other.graph, self.identity, other.identity]):

                return False

            return issubclass(type(self), Node) and issubclass(type(other), Node) and self.graph == other.graph and self.identity == other.identity

        except (AttributeError, TypeError):

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        if self.graph and self.identity:

            return hash(self.graph.database) ^ hash(self.graph.name) ^ hash(self.identity)

        else:

            return hash(id(self))



    def __getitem__(self, item):

        if self.graph is not None and self.identity is not None and "properties" in self._stale:

            self.graph.pull(self)

        return Entity.__getitem__(self, item)



    def __ensure_labels(self):

        if self.graph is not None and self.identity is not None and "labels" in self._stale:

            self.graph.pull(self)



    @property

    def labels(self):

        """ Set of all node labels.

        """

        self.__ensure_labels()

        return LabelSetView(self._labels)



    def has_label(self, label):

        self.__ensure_labels()

        return label in self._labels



    def add_label(self, label):

        self.__ensure_labels()

        self._labels.add(label)



    def remove_label(self, label):

        self.__ensure_labels()

        self._labels.discard(label)



    def clear_labels(self):

        self.__ensure_labels()

        self._labels.clear()



    def update_labels(self, labels):

        self.__ensure_labels()

        self._labels.update(labels)





class Relationship(Entity):

    """ A relationship represents a typed connection between a pair of nodes.



    The positional arguments passed to the constructor identify the nodes to

    relate and the type of the relationship. Keyword arguments describe the

    properties of the relationship::



        >>> from py2neo import Node, Relationship

        >>> a = Node("Person", name="Alice")

        >>> b = Node("Person", name="Bob")

        >>> a_knows_b = Relationship(a, "KNOWS", b, since=1999)



    This class may be extended to allow relationship types names to be

    derived from the class name. For example::



        >>> WORKS_WITH = Relationship.type("WORKS_WITH")

        >>> a_works_with_b = WORKS_WITH(a, b)

        >>> a_works_with_b

        (Alice)-[:WORKS_WITH {}]->(Bob)



    """



    @staticmethod

    def type(name):

        """ Return the :class:`.Relationship` subclass corresponding to a

        given name.



        :param name: relationship type name

        :returns: `type` object

        """

        for s in Relationship.__subclasses__():

            if s.__name__ == name:

                return s

        return type(xstr(name), (Relationship,), {})



    @classmethod

    def cast(cls, obj, entities=None):



        def get_type(r):

            if isinstance(r, string_types):

                return r

            elif isinstance(r, Relationship):

                return type(r).__name__

            elif isinstance(r, tuple) and len(r) == 2 and isinstance(r[0], string_types):

                return r[0]

            else:

                raise ValueError("Cannot determine relationship type from %r" % r)



        def get_properties(r):

            if isinstance(r, string_types):

                return {}

            elif isinstance(r, Relationship):

                return dict(r)

            elif hasattr(r, "properties"):

                return r.properties

            elif isinstance(r, tuple) and len(r) == 2 and isinstance(r[0], string_types):

                return dict(r[1])

            else:

                raise ValueError("Cannot determine properties from %r" % r)



        if isinstance(obj, Relationship):

            return obj

        elif isinstance(obj, tuple):

            if len(obj) == 3:

                start_node, t, end_node = obj

                properties = get_properties(t)

            elif len(obj) == 4:

                start_node, t, end_node, properties = obj

                properties = dict(get_properties(t), **properties)

            else:

                raise TypeError("Cannot cast relationship from %r" % obj)

        else:

            raise TypeError("Cannot cast relationship from %r" % obj)



        if entities:

            if isinstance(start_node, integer_types):

                start_node = entities[start_node]

            if isinstance(end_node, integer_types):

                end_node = entities[end_node]

        return Relationship(start_node, get_type(t), end_node, **properties)



    def __init__(self, *nodes, **properties):

        n = []

        for value in nodes:

            if value is None:

                n.append(None)

            elif isinstance(value, string_types):

                n.append(value)

            else:

                n.append(Node.cast(value))



        num_args = len(n)

        if num_args == 0:

            raise TypeError("Relationships must specify at least one endpoint")

        elif num_args == 1:

            # Relationship(a)

            n = (n[0], n[0])

        elif num_args == 2:

            if n[1] is None or isinstance(n[1], string_types):

                # Relationship(a, "TO")

                self.__class__ = Relationship.type(n[1])

                n = (n[0], n[0])

            else:

                # Relationship(a, b)

                n = (n[0], n[1])

        elif num_args == 3:

            # Relationship(a, "TO", b)

            self.__class__ = Relationship.type(n[1])

            n = (n[0], n[2])

        else:

            raise TypeError("Hyperedges not supported")

        Entity.__init__(self, (n[0], self, n[1]), properties)



        self._stale = set()



    def __eq__(self, other):

        if self is other:

            return True

        try:

            if any(x is None for x in [self.graph, other.graph, self.identity, other.identity]):

                try:

                    return type(self) is type(other) and list(self.nodes) == list(other.nodes) and dict(self) == dict(other)

                except (AttributeError, TypeError):

                    return False

            return issubclass(type(self), Relationship) and issubclass(type(other), Relationship) and self.graph == other.graph and self.identity == other.identity

        except (AttributeError, TypeError):

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        return hash(self.nodes) ^ hash(type(self))





class Path(Walkable):

    """ A sequence of nodes connected by relationships that may

    optionally be bound to remote counterparts in a Neo4j database.



        >>> from py2neo import Node, Path

        >>> alice, bob, carol = Node(name="Alice"), Node(name="Bob"), Node(name="Carol")

        >>> abc = Path(alice, "KNOWS", bob, Relationship(carol, "KNOWS", bob), carol)

        >>> abc

        <Path order=3 size=2>

        >>> abc.nodes

        (<Node labels=set() properties={'name': 'Alice'}>,

         <Node labels=set() properties={'name': 'Bob'}>,

         <Node labels=set() properties={'name': 'Carol'}>)

        >>> abc.relationships

        (<Relationship type='KNOWS' properties={}>,

         <Relationship type='KNOWS' properties={}>)

        >>> dave, eve = Node(name="Dave"), Node(name="Eve")

        >>> de = Path(dave, "KNOWS", eve)

        >>> de

        <Path order=2 size=1>

        >>> abcde = Path(abc, "KNOWS", de)

        >>> abcde

        <Path order=5 size=4>

        >>> for relationship in abcde.relationships:

        ...     print(relationship)

        ({name:"Alice"})-[:KNOWS]->({name:"Bob"})

        ({name:"Carol"})-[:KNOWS]->({name:"Bob"})

        ({name:"Carol"})-[:KNOWS]->({name:"Dave"})

        ({name:"Dave"})-[:KNOWS]->({name:"Eve"})



    """



    def __init__(self, *entities):

        entities = list(entities)

        for i, entity in enumerate(entities):

            if isinstance(entity, Entity):

                continue

            elif entity is None:

                entities[i] = Node()

            elif isinstance(entity, dict):

                entities[i] = Node(**entity)

        for i, entity in enumerate(entities):

            try:

                start_node = entities[i - 1].end_node

                end_node = entities[i + 1].start_node

            except (IndexError, AttributeError):

                pass

            else:

                if isinstance(entity, string_types):

                    entities[i] = Relationship(start_node, entity, end_node)

                elif isinstance(entity, tuple) and len(entity) == 2:

                    t, properties = entity

                    entities[i] = Relationship(start_node, t, end_node, **properties)

        Walkable.__init__(self, walk(*entities))

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from __future__ import absolute_import



from collections import deque, OrderedDict

from datetime import datetime

from time import sleep

from warnings import warn



from py2neo.cypher import cypher_escape

from py2neo.data import Table

from py2neo.internal.caching import ThreadLocalEntityCache

from py2neo.internal.text import Words

from py2neo.internal.compat import Mapping, string_types, xstr

from py2neo.internal.versioning import Version

from py2neo.matching import NodeMatcher, RelationshipMatcher





update_stats_keys = [

    "constraints_added",

    "constraints_removed",

    "indexes_added",

    "indexes_removed",

    "labels_added",

    "labels_removed",

    "nodes_created",

    "nodes_deleted",

    "properties_set",

    "relationships_deleted",

    "relationships_created",

]





class Database(object):

    """ Accessor for an entire Neo4j graph database installation over

    Bolt or HTTP. Within the py2neo object hierarchy, a :class:`.Database`

    contains a :class:`.Graph` in which most activity occurs. Currently,

    Neo4j only supports one `Graph` per `Database`.



    An explicit URI can be passed to the constructor::



        >>> from py2neo import Database

        >>> db = Database("bolt://camelot.example.com:7687")



    Alternatively, the default value of ``bolt://localhost:7687`` is

    used::



        >>> default_db = Database()

        >>> default_db

        <Database uri='bolt://localhost:7687'>



    """



    _instances = {}



    _cx_pool = None

    # _driver = None

    _connector = None

    _graphs = None



    @classmethod

    def forget_all(cls):

        """ Forget all cached :class:`.Database` details.

        """

        for _, db in cls._instances.items():

            # db._driver.close()

            # db._driver = None

            db._connector.close()

            db._connector = None

        cls._instances.clear()



    def __new__(cls, uri=None, **settings):

        from py2neo.internal.connectors import get_connection_data

        connection_data = get_connection_data(uri, **settings)

        key = connection_data["hash"]

        try:

            inst = cls._instances[key]

        except KeyError:

            inst = super(Database, cls).__new__(cls)

            inst._connection_data = connection_data

            from py2neo.internal.connectors import Connector

            inst._connector = Connector(

                connection_data["uri"],

                auth=connection_data["auth"],

                secure=connection_data["secure"],

                user_agent=connection_data["user_agent"],

                max_connections=settings.get("max_connections"),

            )

            inst._graphs = {}

            cls._instances[key] = inst

        return inst



    def __repr__(self):

        class_name = self.__class__.__name__

        data = self._connection_data

        return "<%s uri=%r secure=%r user_agent=%r>" % (

            class_name, data["uri"], data["secure"], data["user_agent"])



    def __eq__(self, other):

        try:

            return self.uri == other.uri

        except AttributeError:

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    def __hash__(self):

        return hash(self._connection_data["hash"])



    def __contains__(self, database):

        return database in self._graphs



    def __getitem__(self, database):

        if database == "data" and database not in self._graphs:

            self._graphs[database] = Graph(**self._connection_data)

        return self._graphs[database]



    def __setitem__(self, database, graph):

        self._graphs[database] = graph



    def __iter__(self):

        yield "data"



    @property

    def connector(self):

        return self._connector



    @property

    def uri(self):

        """ The URI to which this `Database` is connected.

        """

        return self._connection_data["uri"]



    @property

    def default_graph(self):

        """ The default graph exposed by this database.



        :rtype: :class:`.Graph`

        """

        return self["data"]



    def keys(self):

        return list(self)



    def query_jmx(self, namespace, instance=None, name=None, type=None):

        """ Query the JMX service attached to this database.

        """

        d = {}

        for nom, _, attributes in self.default_graph.run("CALL dbms.queryJmx('')"):

            ns, _, terms = nom.partition(":")

            if ns != namespace:

                continue

            terms = dict(tuple(term.partition("=")[0::2]) for term in terms.split(","))

            if instance is not None and instance != terms["instance"]:

                continue

            if name is not None and name != terms["name"]:

                continue

            if type is not None and type != terms["type"]:

                continue

            for attr_name, attr_data in attributes.items():

                attr_value = attr_data.get("value")

                if attr_value == "true":

                    d[attr_name] = True

                elif attr_value == "false":

                    d[attr_name] = False

                elif isinstance(attr_value, string_types) and "." in attr_value:

                    try:

                        d[attr_name] = float(attr_value)

                    except (TypeError, ValueError):

                        d[attr_name] = attr_value

                else:

                    try:

                        d[attr_name] = int(attr_value)

                    except (TypeError, ValueError):

                        d[attr_name] = attr_value

        return d



    @property

    def name(self):

        """ Return the name of the active Neo4j database.

        """

        info = self.query_jmx("org.neo4j", name="Kernel")

        return info.get("DatabaseName")



    @property

    def kernel_start_time(self):

        """ Return the time from which this Neo4j instance was in operational mode.

        """

        info = self.query_jmx("org.neo4j", name="Kernel")

        return datetime.fromtimestamp(info["KernelStartTime"] / 1000.0)



    @property

    def kernel_version(self):

        """ Return the version of Neo4j.

        """

        info = self.query_jmx("org.neo4j", name="Kernel")

        version_string = info["KernelVersion"].partition("version:")[-1].partition(",")[0].strip()

        return Version.parse(version_string).major_minor_patch



    @property

    def product(self):

        """ Return the product name.

        """

        info = self.query_jmx("org.neo4j", name="Kernel")

        return info["KernelVersion"]



    @property

    def store_creation_time(self):

        """ Return the time when this Neo4j graph store was created.

        """

        info = self.query_jmx("org.neo4j", name="Kernel")

        return datetime.fromtimestamp(info["StoreCreationDate"] / 1000.0)



    @property

    def store_id(self):

        """ Return an identifier that, together with store creation time,

        uniquely identifies this Neo4j graph store.

        """

        info = self.query_jmx("org.neo4j", name="Kernel")

        return info["StoreId"]



    @property

    def primitive_counts(self):

        """ Return a dictionary of estimates of the numbers of different

        kinds of Neo4j primitives.

        """

        return self.query_jmx("org.neo4j", name="Primitive count")



    @property

    def store_file_sizes(self):

        """ Return a dictionary of file sizes for each file in the Neo4j

        graph store.

        """

        return self.query_jmx("org.neo4j", name="Store file sizes")



    @property

    def config(self):

        """ Return a dictionary of the configuration parameters used to

        configure Neo4j.

        """

        return self.query_jmx("org.neo4j", name="Configuration")





class Graph(object):

    """ The `Graph` class represents the graph data storage space within

    a Neo4j graph database. Connection details are provided using URIs

    and/or individual settings.



    Supported URI schemes are:



    - ``http``

    - ``https``

    - ``bolt``



    The full set of supported `settings` are:



    ===================  ========================================================  ==============  =========================

    Keyword              Description                                               Type            Default

    ===================  ========================================================  ==============  =========================

    ``auth``             A 2-tuple of (user, password)                             tuple           ``('neo4j', 'password')``

    ``host``             Database server host name                                 str             ``'localhost'``

    ``password``         Password to use for authentication                        str             ``'password'``

    ``port``             Database server port                                      int             ``7687``

    ``scheme``           Use a specific URI scheme                                 str             ``'bolt'``

    ``secure``           Use a secure connection (TLS)                             bool            ``False``

    ``user``             User to authenticate as                                   str             ``'neo4j'``

    ``user_agent``       User agent to send for all connections                    str             `(depends on URI scheme)`

    ``max_connections``  The maximum number of simultaneous connections permitted  int             40

    ===================  ========================================================  ==============  =========================



    Each setting can be provided as a keyword argument or as part of

    an ``http:``, ``https:`` or ``bolt:`` URI. Therefore, the examples

    below are equivalent::



        >>> from py2neo import Graph

        >>> graph_1 = Graph()

        >>> graph_2 = Graph(host="localhost")

        >>> graph_3 = Graph("bolt://localhost:7687")



    Once obtained, the `Graph` instance provides direct or indirect

    access to most of the functionality available within py2neo.



    Note that py2neo does not support routing with a Neo4j causal cluster

    (bolt+routing). For this functionality, please use the official Neo4j

    Driver for Python.

    """



    #: The :class:`.Database` to which this :class:`.Graph` belongs.

    database = None



    #: The :class:`.Schema` resource for this :class:`.Graph`.

    schema = None



    node_cache = ThreadLocalEntityCache()

    relationship_cache = ThreadLocalEntityCache()



    def __new__(cls, uri=None, **settings):

        name = settings.pop("name", "data")

        database = Database(uri, **settings)

        if name in database:

            inst = database[name]

        else:

            inst = object.__new__(cls)

            inst.database = database

            inst.schema = Schema(inst)

            inst.__name__ = name

            database[name] = inst

        return inst



    def __repr__(self):

        return "<Graph database=%r name=%r>" % (self.database, self.__name__)



    def __eq__(self, other):

        try:

            return self.database == other.database and self.__name__ == other.__name__

        except (AttributeError, TypeError):

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    def __len__(self):

        return len(self.relationships)



    def __bool__(self):

        return True



    __nonzero__ = __bool__



    def begin(self, autocommit=False):

        """ Begin a new :class:`.Transaction`.



        :param autocommit: if :py:const:`True`, the transaction will

                         automatically commit after the first operation

        """

        return Transaction(self, autocommit)



    def create(self, subgraph):

        """ Run a :meth:`.Transaction.create` operation within a

        :class:`.Transaction`.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph`

        """

        with self.begin() as tx:

            tx.create(subgraph)



    def delete(self, subgraph):

        """ Run a :meth:`.Transaction.delete` operation within an

        `autocommit` :class:`.Transaction`. To delete only the

        relationships, use the :meth:`.separate` method.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph` object

        """

        self.begin(autocommit=True).delete(subgraph)



    def delete_all(self):

        """ Delete all nodes and relationships from this :class:`.Graph`.



        .. warning::

            This method will permanently remove **all** nodes and relationships

            from the graph and cannot be undone.

        """

        self.run("MATCH (a) DETACH DELETE a")

        self.node_cache.clear()

        self.relationship_cache.clear()



    def evaluate(self, cypher, parameters=None, **kwparameters):

        """ Run a :meth:`.Transaction.evaluate` operation within an

        `autocommit` :class:`.Transaction`.



        :param cypher: Cypher statement

        :param parameters: dictionary of parameters

        :return: first value from the first record returned or

                 :py:const:`None`.

        """

        return self.begin(autocommit=True).evaluate(cypher, parameters, **kwparameters)



    def exists(self, subgraph):

        """ Run a :meth:`.Transaction.exists` operation within an

        `autocommit` :class:`.Transaction`.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph` object

        :return:

        """

        return self.begin(autocommit=True).exists(subgraph)



    def match(self, nodes=None, r_type=None, limit=None):

        """ Match and return all relationships with specific criteria.



        For example, to find all of Alice's friends::



            for rel in graph.match((alice, ), r_type="FRIEND"):

                print(rel.end_node["name"])



        :param nodes: Sequence or Set of start and end nodes (:const:`None` means any node);

                a Set implies a match in any direction

        :param r_type: type of relationships to match (:const:`None` means any type)

        :param limit: maximum number of relationships to match (:const:`None` means unlimited)

        """

        return RelationshipMatcher(self).match(nodes=nodes, r_type=r_type).limit(limit)



    def match_one(self, nodes=None, r_type=None):

        """ Match and return one relationship with specific criteria.



        :param nodes: Sequence or Set of start and end nodes (:const:`None` means any node);

                a Set implies a match in any direction

        :param r_type: type of relationships to match (:const:`None` means any type)

        """

        matches = self.match(nodes=nodes, r_type=r_type, limit=1)

        rels = list(matches)

        if rels:

            return rels[0]

        else:

            return None



    def merge(self, subgraph, label=None, *property_keys):

        """ Run a :meth:`.Transaction.merge` operation within an

        `autocommit` :class:`.Transaction`.



        The example code below shows a simple merge for a new relationship

        between two new nodes:



            >>> from py2neo import Graph, Node, Relationship

            >>> g = Graph()

            >>> a = Node("Person", name="Alice", age=33)

            >>> b = Node("Person", name="Bob", age=44)

            >>> KNOWS = Relationship.type("KNOWS")

            >>> g.merge(KNOWS(a, b), "Person", "name")



        Following on, we then create a third node (of a different type) to

        which both the original nodes connect:



            >>> c = Node("Company", name="ACME")

            >>> c.__primarylabel__ = "Company"

            >>> c.__primarykey__ = "name"

            >>> WORKS_FOR = Relationship.type("WORKS_FOR")

            >>> g.merge(WORKS_FOR(a, c) | WORKS_FOR(b, c))



        For details of how the merge algorithm works, see the

        :meth:`.Transaction.merge` method. Note that this is different

        to a Cypher MERGE.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph` object

        :param label: label on which to match any existing nodes

        :param property_keys: property keys on which to match any existing nodes

        """

        with self.begin() as tx:

            tx.merge(subgraph, label, *property_keys)



    @property

    def name(self):

        return self.__name__



    @property

    def nodes(self):

        """ Obtain a :class:`.NodeMatcher` for this graph.



        This can be used to find nodes that match given criteria:



            >>> graph = Graph()

            >>> graph.nodes[1234]

            (_1234:Person {name: 'Alice'})

            >>> graph.nodes.get(1234)

            (_1234:Person {name: 'Alice'})

            >>> graph.nodes.match("Person", name="Alice").first()

            (_1234:Person {name: 'Alice'})



        Nodes can also be efficiently counted using this attribute:



            >>> len(graph.nodes)

            55691

            >>> len(graph.nodes.match("Person", age=33))

            12



        """

        return NodeMatcher(self)



    def pull(self, subgraph):

        """ Pull data to one or more entities from their remote counterparts.



        :param subgraph: the collection of nodes and relationships to pull

        """

        with self.begin() as tx:

            tx.pull(subgraph)



    def push(self, subgraph):

        """ Push data from one or more entities to their remote counterparts.



        :param subgraph: the collection of nodes and relationships to push

        """

        with self.begin() as tx:

            tx.push(subgraph)



    @property

    def relationships(self):

        """ Obtain a :class:`.RelationshipMatcher` for this graph.



        This can be used to find relationships that match given criteria

        as well as efficiently count relationships.

        """

        return RelationshipMatcher(self)



    def run(self, cypher, parameters=None, **kwparameters):

        """ Run a :meth:`.Transaction.run` operation within an

        `autocommit` :class:`.Transaction`.



        :param cypher: Cypher statement

        :param parameters: dictionary of parameters

        :param kwparameters: extra keyword parameters

        :return:

        """

        return self.begin(autocommit=True).run(cypher, parameters, **kwparameters)



    def separate(self, subgraph):

        """ Run a :meth:`.Transaction.separate` operation within an

        `autocommit` :class:`.Transaction`.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph`

        """

        self.begin(autocommit=True).separate(subgraph)





class Schema(object):

    """ The schema resource attached to a `Graph` instance.

    """



    def __init__(self, graph):

        self.graph = graph



    @property

    def node_labels(self):

        """ The set of node labels currently defined within the graph.

        """

        return frozenset(record[0] for record in

                         self.graph.run("CALL db.labels"))



    @property

    def relationship_types(self):

        """ The set of relationship types currently defined within the graph.

        """

        return frozenset(record[0] for record in

                         self.graph.run("CALL db.relationshipTypes"))



    def create_index(self, label, *property_keys):

        """ Create a schema index for a label and property

        key combination.

        """

        cypher = "CREATE INDEX ON :{}({})".format(

            cypher_escape(label), ", ".join(map(cypher_escape, property_keys)))

        self.graph.run(cypher).close()

        while property_keys not in self.get_indexes(label):

            sleep(0.1)



    def create_uniqueness_constraint(self, label, property_key):

        """ Create a node uniqueness constraint for a given label and property

        key.



        While indexes support the use of composite keys, unique constraints may

        only be tied to a single property key.

        """

        cypher = "CREATE CONSTRAINT ON (_:{}) ASSERT _.{} IS UNIQUE".format(

            cypher_escape(label), cypher_escape(property_key))

        self.graph.run(cypher).close()

        while property_key not in self.get_uniqueness_constraints(label):

            sleep(0.1)



    def drop_index(self, label, *property_keys):

        """ Remove label index for a given property key.

        """

        cypher = "DROP INDEX ON :{}({})".format(

            cypher_escape(label), ", ".join(map(cypher_escape, property_keys)))

        self.graph.run(cypher).close()



    def drop_uniqueness_constraint(self, label, property_key):

        """ Remove the node uniqueness constraint for a given label and

        property key.

        """

        cypher = "DROP CONSTRAINT ON (_:{}) ASSERT _.{} IS UNIQUE".format(

            cypher_escape(label), cypher_escape(property_key))

        self.graph.run(cypher).close()



    def _get_indexes(self, label, t=None):

        indexes = []

        for record in self.graph.run("CALL db.indexes"):

            properties = []

            # The code branches here depending on the format of the response

            # from the `db.indexes` procedure, which has varied enormously

            # over the entire 3.x series.

            if len(record) == 10:

                # 3.5.0

                (description, index_name, token_names, properties, state,

                 type_, progress, provider, id_, failure_message) = record

            elif len(record) == 7:

                # 3.4.10

                (description, lbl, properties, state,

                 type_, provider, failure_message) = record

                token_names = [lbl]

            elif len(record) == 6:

                # 3.4.7

                description, lbl, properties, state, type_, provider = record

                token_names = [lbl]

            elif len(record) == 3:

                # 3.0.10

                description, state, type_ = record

                token_names = []

            else:

                raise RuntimeError("Unexpected response from procedure "

                                   "db.indexes (%d fields)" % len(record))

            if state not in (u"ONLINE", u"online"):

                continue

            if t and type_ != t:

                continue

            if not token_names or not properties:

                from py2neo.cypher.lexer import CypherLexer

                from pygments.token import Token

                tokens = list(CypherLexer().get_tokens(description))

                for token_type, token_value in tokens:

                    if token_type is Token.Name.Label:

                        token_names.append(token_value.strip("`"))

                    elif token_type is Token.Name.Variable:

                        properties.append(token_value.strip("`"))

            if not token_names or not properties:

                continue

            if label in token_names:

                indexes.append(tuple(properties))

        return indexes



    def get_indexes(self, label):

        """ Fetch a list of indexed property keys for a label.

        """

        return self._get_indexes(label)



    def get_uniqueness_constraints(self, label):

        """ Fetch a list of unique constraints for a label. Each constraint is

        the name of a single property key.

        """

        return [k[0] for k in self._get_indexes(label, "node_unique_property")]





class GraphError(Exception):

    """

    """



    __cause__ = None



    http_status_code = None

    code = None

    message = None



    @classmethod

    def hydrate(cls, data):

        code = data["code"]

        message = data["message"]

        _, classification, category, title = code.split(".")

        if classification == "ClientError":

            try:

                error_cls = ClientError.get_mapped_class(code)

            except KeyError:

                error_cls = ClientError

                message = "%s: %s" % (Words(title).camel(upper_first=True), message)

        elif classification == "DatabaseError":

            error_cls = DatabaseError

        elif classification == "TransientError":

            error_cls = TransientError

        else:

            error_cls = cls

        inst = error_cls(message)

        inst.code = code

        inst.message = message

        return inst



    def __new__(cls, *args, **kwargs):

        try:

            exception = kwargs["exception"]

            error_cls = type(xstr(exception), (cls,), {})

        except KeyError:

            error_cls = cls

        return Exception.__new__(error_cls, *args)



    def __init__(self, *args, **kwargs):

        Exception.__init__(self, *args)

        for key, value in kwargs.items():

            setattr(self, key.lower(), value)





class ClientError(GraphError):

    """ The Client sent a bad request - changing the request might yield a successful outcome.

    """



    @classmethod

    def get_mapped_class(cls, status):

        raise KeyError(status)

        from neobolt.exceptions import ConstraintError, CypherSyntaxError, CypherTypeError, Forbidden, AuthError

        return {



            # ConstraintError

            "Neo.ClientError.Schema.ConstraintValidationFailed": ConstraintError,

            "Neo.ClientError.Schema.ConstraintViolation": ConstraintError,

            "Neo.ClientError.Statement.ConstraintVerificationFailed": ConstraintError,

            "Neo.ClientError.Statement.ConstraintViolation": ConstraintError,



            # CypherSyntaxError

            "Neo.ClientError.Statement.InvalidSyntax": CypherSyntaxError,

            "Neo.ClientError.Statement.SyntaxError": CypherSyntaxError,



            # CypherTypeError

            "Neo.ClientError.Procedure.TypeError": CypherTypeError,

            "Neo.ClientError.Statement.InvalidType": CypherTypeError,

            "Neo.ClientError.Statement.TypeError": CypherTypeError,



            # Forbidden

            "Neo.ClientError.General.ForbiddenOnReadOnlyDatabase": Forbidden,

            "Neo.ClientError.General.ReadOnly": Forbidden,

            "Neo.ClientError.Schema.ForbiddenOnConstraintIndex": Forbidden,

            "Neo.ClientError.Schema.IndexBelongsToConstrain": Forbidden,

            "Neo.ClientError.Security.Forbidden": Forbidden,

            "Neo.ClientError.Transaction.ForbiddenDueToTransactionType": Forbidden,



            # Unauthorized

            "Neo.ClientError.Security.AuthorizationFailed": AuthError,

            "Neo.ClientError.Security.Unauthorized": AuthError,



        }[status]





class DatabaseError(GraphError):

    """ The database failed to service the request.

    """





class TransientError(GraphError):

    """ The database cannot service the request right now, retrying later might yield a successful outcome.

    """





class TransactionError(GraphError):

    """ Raised when actions are attempted against a :class:`.Transaction`

    that is no longer available for use, or a transaction is otherwise invalid.

    """





class Transaction(object):

    """ A transaction is a logical container for multiple Cypher statements.

    """



    # session = None



    _finished = False



    def __init__(self, graph, autocommit=False):

        self.graph = graph

        self.autocommit = autocommit

        self.entities = deque()

        self.connector = self.graph.database.connector

        self.results = []

        if autocommit:

            self.transaction = None

        else:

            self.transaction = self.connector.begin()



    # def __del__(self):

    #     if self.session:

    #         self.session.close()



    def __enter__(self):

        return self



    def __exit__(self, exc_type, exc_val, exc_tb):

        if exc_type is None:

            self.commit()

        else:

            self._rollback()



    def _assert_unfinished(self):

        if self._finished:

            raise TransactionError(self)



    def finished(self):

        """ Indicates whether or not this transaction has been completed

        or is still open.

        """

        return self._finished



    def run(self, cypher, parameters=None, **kwparameters):

        """ Send a Cypher statement to the server for execution and return

        a :py:class:`.Cursor` for navigating its result.



        :param cypher: Cypher statement

        :param parameters: dictionary of parameters

        :returns: :py:class:`.Cursor` object

        """

        from neobolt.exceptions import CypherError



        self._assert_unfinished()

        try:

            entities = self.entities.popleft()

        except IndexError:

            entities = {}



        try:

            return Cursor(self.connector.run(statement=cypher,

                                             parameters=dict(parameters or {}, **kwparameters),

                                             tx=self.transaction,

                                             graph=self.graph,

                                             keys=[],

                                             entities=entities))

        except CypherError as error:

            raise GraphError.hydrate({"code": error.code, "message": error.message})

        finally:

            if not self.transaction:

                self.finish()



    def process(self):

        """ Send all pending statements to the server for processing.

        """

        self._assert_unfinished()

        if self.transaction:

            self.connector.sync(self.transaction)



    def finish(self):

        self.process()

        self._assert_unfinished()

        self._finished = True



    def commit(self):

        """ Commit the transaction.

        """

        self._assert_unfinished()

        self.connector.commit(self.transaction)

        self._finished = True



    def _rollback(self):

        """ Implicit rollback.

        """

        if self.connector.is_valid_transaction(self.transaction):

            self.connector.rollback(self.transaction)

        self._finished = True



    def rollback(self):

        """ Roll back the current transaction, undoing all actions previously taken.

        """

        self._assert_unfinished()

        self.connector.rollback(self.transaction)

        self._finished = True



    def evaluate(self, cypher, parameters=None, **kwparameters):

        """ Execute a single Cypher statement and return the value from

        the first column of the first record.



        :param cypher: Cypher statement

        :param parameters: dictionary of parameters

        :returns: single return value or :const:`None`

        """

        return self.run(cypher, parameters, **kwparameters).evaluate(0)



    def create(self, subgraph):

        """ Create remote nodes and relationships that correspond to those in a

        local subgraph. Any entities in *subgraph* that are already bound to

        remote entities will remain unchanged, those which are not will become

        bound to their newly-created counterparts.



        For example::



            >>> from py2neo import Graph, Node, Relationship

            >>> g = Graph()

            >>> tx = g.begin()

            >>> a = Node("Person", name="Alice")

            >>> tx.create(a)

            >>> b = Node("Person", name="Bob")

            >>> ab = Relationship(a, "KNOWS", b)

            >>> tx.create(ab)

            >>> tx.commit()

            >>> g.exists(ab)

            True



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                    creatable object

        """

        try:

            create = subgraph.__db_create__

        except AttributeError:

            raise TypeError("No method defined to create object %r" % subgraph)

        else:

            create(self)



    def delete(self, subgraph):

        """ Delete the remote nodes and relationships that correspond to

        those in a local subgraph. To delete only the relationships, use

        the :meth:`.separate` method.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph`

        """

        try:

            delete = subgraph.__db_delete__

        except AttributeError:

            raise TypeError("No method defined to delete object %r" % subgraph)

        else:

            delete(self)



    def exists(self, subgraph):

        """ Determine whether one or more graph entities all exist within the

        database. Note that if any nodes or relationships in *subgraph* are not

        bound to remote counterparts, this method will return ``False``.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph`

        :returns: ``True`` if all entities exist remotely, ``False`` otherwise

        """

        try:

            exists = subgraph.__db_exists__

        except AttributeError:

            raise TypeError("No method defined to check existence of object %r" % subgraph)

        else:

            return exists(self)



    def merge(self, subgraph, primary_label=None, primary_key=None):

        """ Create or update the nodes and relationships of a local

        subgraph in the remote database. Note that the functionality of

        this operation is not strictly identical to the Cypher MERGE

        clause, although there is some overlap.



        Each node and relationship in the local subgraph is merged

        independently, with nodes merged first and relationships merged

        second.



        For each node, the merge is carried out by comparing that node with

        a potential remote equivalent on the basis of a single label and

        property value. If no remote match is found, a new node is created;

        if a match is found, the labels and properties of the remote node

        are updated. The label and property used for comparison are determined

        by the `primary_label` and `primary_key` arguments but may be

        overridden for individual nodes by the of `__primarylabel__` and

        `__primarykey__` attributes on the node itself.



        For each relationship, the merge is carried out by comparing that

        relationship with a potential remote equivalent on the basis of matching

        start and end nodes plus relationship type. If no remote match is found,

        a new relationship is created; if a match is found, the properties of

        the remote relationship are updated.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph` object

        :param primary_label: label on which to match any existing nodes

        :param primary_key: property key(s) on which to match any existing

                            nodes

        """

        try:

            merge = subgraph.__db_merge__

        except AttributeError:

            raise TypeError("No method defined to merge object %r" % subgraph)

        else:

            merge(self, primary_label, primary_key)



    def pull(self, subgraph):

        """ Update local entities from their remote counterparts.



        For any nodes and relationships that exist in both the local

        :class:`.Subgraph` and the remote :class:`.Graph`, pull properties

        and node labels into the local copies. This operation does not

        create or delete any entities.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph`

        """

        try:

            pull = subgraph.__db_pull__

        except AttributeError:

            raise TypeError("No method defined to pull object %r" % subgraph)

        else:

            return pull(self)



    def push(self, subgraph):

        """ Update remote entities from their local counterparts.



        For any nodes and relationships that exist in both the local

        :class:`.Subgraph` and the remote :class:`.Graph`, push properties

        and node labels into the remote copies. This operation does not

        create or delete any entities.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph`

        """

        try:

            push = subgraph.__db_push__

        except AttributeError:

            raise TypeError("No method defined to push object %r" % subgraph)

        else:

            return push(self)



    def separate(self, subgraph):

        """ Delete the remote relationships that correspond to those in a local

        subgraph. This leaves any nodes untouched.



        :param subgraph: a :class:`.Node`, :class:`.Relationship` or other

                       :class:`.Subgraph`

        """

        try:

            separate = subgraph.__db_separate__

        except AttributeError:

            raise TypeError("No method defined to separate object %r" % subgraph)

        else:

            separate(self)





class Cursor(object):

    """ A `Cursor` is a navigator for a stream of records.



    A cursor can be thought of as a window onto an underlying data

    stream. All cursors in py2neo are "forward-only", meaning that

    navigation starts before the first record and may proceed only in a

    forward direction.



    It is not generally necessary for application code to instantiate a

    cursor directly as one will be returned by any Cypher execution method.

    However, cursor creation requires only a :class:`.DataSource` object

    which contains the logic for how to access the source data that the

    cursor navigates.



    Many simple cursor use cases require only the :meth:`.forward` method

    and the :attr:`.current` attribute. To navigate through all available

    records, a `while` loop can be used::



        while cursor.forward():

            print(cursor.current["name"])



    If only the first record is of interest, a similar `if` structure will

    do the job::



        if cursor.forward():

            print(cursor.current["name"])



    To combine `forward` and `current` into a single step, use the built-in

    py:func:`next` function::



        print(next(cursor)["name"])



    Cursors are also iterable, so can be used in a loop::



        for record in cursor:

            print(record["name"])



    For queries that are expected to return only a single value within a

    single record, use the :meth:`.evaluate` method. This will return the

    first value from the next record or :py:const:`None` if neither the

    field nor the record are present::



        print(cursor.evaluate())



    """



    def __init__(self, result):

        self._result = result

        self._current = None



    def __del__(self):

        try:

            self.close()

        except:

            pass



    def __next__(self):

        if self.forward():

            return self._current

        else:

            raise StopIteration()



    # Exists only for Python 2 iteration compatibility

    next = __next__



    def __iter__(self):

        while self.forward():

            yield self._current



    def __getitem__(self, key):

        return self._current[key]



    @property

    def current(self):

        """ Returns the current record or :py:const:`None` if no record

        has yet been selected.

        """

        return self._current



    def close(self):

        """ Close this cursor and free up all associated resources.

        """

        if self._result is not None:

            self._result.buffer()   # force consumption of remaining data

            self._result = None

        self._current = None



    def keys(self):

        """ Return the field names for the records in the stream.

        """

        return self._result.keys()



    def summary(self):

        """ Return the result summary.

        """

        return self._result.summary()



    def plan(self):

        """ Return the plan returned with this result, if any.

        """

        return self._result.plan()



    def stats(self):

        """ Return the query statistics.



        This contains details of the activity undertaken by the database

        kernel for the query, such as the number of entities created or

        deleted. Specifically, this returns a :class:`.CypherStats` object.



        >>> from py2neo import Graph

        >>> g = Graph()

        >>> g.run("CREATE (a:Person) SET a.name = 'Alice'").stats()

        constraints_added: 0

        constraints_removed: 0

        contained_updates: True

        indexes_added: 0

        indexes_removed: 0

        labels_added: 1

        labels_removed: 0

        nodes_created: 1

        nodes_deleted: 0

        properties_set: 1

        relationships_created: 0

        relationships_deleted: 0



        """

        return self._result.stats()



    def forward(self, amount=1):

        """ Attempt to move the cursor one position forward (or by

        another amount if explicitly specified). The cursor will move

        position by up to, but never more than, the amount specified.

        If not enough scope for movement remains, only that remainder

        will be consumed. The total amount moved is returned.



        :param amount: the amount to move the cursor

        :returns: the amount that the cursor was able to move

        """

        if amount == 0:

            return 0

        assert amount > 0

        amount = int(amount)

        moved = 0

        fetch = self._result.fetch

        while moved != amount:

            new_current = fetch()

            if new_current is None:

                break

            else:

                self._current = new_current

                moved += 1

        return moved



    def evaluate(self, field=0):

        """ Return the value of the first field from the next record

        (or the value of another field if explicitly specified).



        This method attempts to move the cursor one step forward and,

        if successful, selects and returns an individual value from

        the new current record. By default, this value will be taken

        from the first value in that record but this can be overridden

        with the `field` argument, which can represent either a

        positional index or a textual key.



        If the cursor cannot be moved forward or if the record contains

        no values, :py:const:`None` will be returned instead.



        This method is particularly useful when it is known that a

        Cypher query returns only a single value.



        :param field: field to select value from (optional)

        :returns: value of the field or :py:const:`None`



        Example:

            >>> from py2neo import Graph

            >>> g = Graph()

            >>> g.run("MATCH (a) WHERE a.email={x} RETURN a.name", x="bob@acme.com").evaluate()

            'Bob Robertson'

        """

        if self.forward():

            try:

                return self[field]

            except IndexError:

                return None

        else:

            return None



    def data(self):

        """ Consume and extract the entire result as a list of

        dictionaries.



        ::



            >>> from py2neo import Graph

            >>> graph = Graph()

            >>> graph.run("MATCH (a:Person) RETURN a.name, a.born LIMIT 4").data()

            [{'a.born': 1964, 'a.name': 'Keanu Reeves'},

             {'a.born': 1967, 'a.name': 'Carrie-Anne Moss'},

             {'a.born': 1961, 'a.name': 'Laurence Fishburne'},

             {'a.born': 1960, 'a.name': 'Hugo Weaving'}]



        :return: the full query result

        :rtype: `list` of `dict`

        """

        return [record.data() for record in self]



    def to_table(self):

        """ Consume and extract the entire result as a :class:`.Table`

        object.



        :return: the full query result

        """

        return Table(self)



    def to_subgraph(self):

        """ Consume and extract the entire result as a :class:`.Subgraph`

        containing the union of all the graph structures within.



        :return: :class:`.Subgraph` object

        """

        s = None

        for record in self:

            s_ = record.to_subgraph()

            if s_ is not None:

                if s is None:

                    s = s_

                else:

                    s |= s_

        return s



    def to_ndarray(self, dtype=None, order='K'):

        """ Consume and extract the entire result as a

        `numpy.ndarray <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html>`_.



        .. note::

           This method requires `numpy` to be installed.



        :param dtype:

        :param order:

        :warns: If `numpy` is not installed

        :returns: `ndarray <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html>`__ object.

        """

        try:

            from numpy import array

        except ImportError:

            warn("Numpy is not installed.")

            raise

        else:

            return array(list(map(list, self)), dtype=dtype, order=order)



    def to_series(self, field=0, index=None, dtype=None):

        """ Consume and extract one field of the entire result as a

        `pandas.Series <http://pandas.pydata.org/pandas-docs/stable/dsintro.html#series>`_.



        .. note::

           This method requires `pandas` to be installed.



        :param field:

        :param index:

        :param dtype:

        :warns: If `pandas` is not installed

        :returns: `Series <http://pandas.pydata.org/pandas-docs/stable/dsintro.html#series>`__ object.

        """

        try:

            from pandas import Series

        except ImportError:

            warn("Pandas is not installed.")

            raise

        else:

            return Series([record[field] for record in self], index=index, dtype=dtype)



    def to_data_frame(self, index=None, columns=None, dtype=None):

        """ Consume and extract the entire result as a

        `pandas.DataFrame <http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dataframe>`_.



        ::



            >>> from py2neo import Graph

            >>> graph = Graph()

            >>> graph.run("MATCH (a:Person) RETURN a.name, a.born LIMIT 4").to_data_frame()

               a.born              a.name

            0    1964        Keanu Reeves

            1    1967    Carrie-Anne Moss

            2    1961  Laurence Fishburne

            3    1960        Hugo Weaving



        .. note::

           This method requires `pandas` to be installed.



        :param index: Index to use for resulting frame.

        :param columns: Column labels to use for resulting frame.

        :param dtype: Data type to force.

        :warns: If `pandas` is not installed

        :returns: `DataFrame <http://pandas.pydata.org/pandas-docs/stable/dsintro.html#series>`__ object.

        """

        try:

            from pandas import DataFrame

        except ImportError:

            warn("Pandas is not installed.")

            raise

        else:

            return DataFrame(list(map(dict, self)), index=index, columns=columns, dtype=dtype)



    def to_matrix(self, mutable=False):

        """ Consume and extract the entire result as a

        `sympy.Matrix <http://docs.sympy.org/latest/tutorial/matrices.html>`_.



        .. note::

           This method requires `sympy` to be installed.



        :param mutable:

        :returns: `Matrix <http://docs.sympy.org/latest/tutorial/matrices.html>`_ object.

        """

        try:

            from sympy import MutableMatrix, ImmutableMatrix

        except ImportError:

            warn("Sympy is not installed.")

            raise

        else:

            if mutable:

                return MutableMatrix(list(map(list, self)))

            else:

                return ImmutableMatrix(list(map(list, self)))





class CypherSummary(object):



    def __init__(self, **data):

        self._data = data



    @property

    def connection(self):

        return self._data.get("connection")





class CypherStats(Mapping):

    """ Container for a set of statistics drawn from Cypher query execution.



    Each value can be accessed as either an attribute or via a string index.

    This class implements :py:class:`.Mapping` to allow it to be used as a

    dictionary.

    """



    #: Boolean flag to indicate whether or not the query contained an update.

    contained_updates = False

    #: Number of nodes created.

    nodes_created = 0

    #: Number of nodes deleted.

    nodes_deleted = 0

    #: Number of property values set.

    properties_set = 0

    #: Number of relationships created.

    relationships_created = 0

    #: Number of relationships deleted.

    relationships_deleted = 0

    #: Number of node labels added.

    labels_added = 0

    #: Number of node labels removed.

    labels_removed = 0

    #: Number of indexes added.

    indexes_added = 0

    #: Number of indexes removed.

    indexes_removed = 0

    #: Number of constraints added.

    constraints_added = 0

    #: Number of constraints removed.

    constraints_removed = 0



    def __init__(self, **stats):

        for key, value in stats.items():

            key = key.replace("-", "_")

            if key.startswith("relationship_"):

                # hack for server bug

                key = "relationships_" + key[13:]

            if hasattr(self.__class__, key):

                setattr(self, key, value)

            self.contained_updates = bool(sum(getattr(self, k, 0)

                                              for k in self.keys()))



    def __repr__(self):

        lines = []

        for key in sorted(self.keys()):

            lines.append("{}: {}".format(key, getattr(self, key)))

        return "\n".join(lines)



    def __getitem__(self, key):

        return getattr(self, key)



    def __len__(self):

        return len(self.keys())



    def __iter__(self):

        return iter(self.keys())



    def keys(self):

        """ Full list of the key or attribute names of the statistics

        available.

        """

        return [key for key in vars(self.__class__).keys()

                if not key.startswith("_") and key != "keys"]





class CypherPlan(Mapping):



    @classmethod

    def _clean_key(cls, key):

        return Words(key).snake()



    @classmethod

    def _clean_keys(cls, data):

        return OrderedDict(sorted((cls._clean_key(key), value) for key, value in dict(data).items()))



    def __init__(self, **kwargs):

        data = self._clean_keys(kwargs)

        if "root" in data:

            data = self._clean_keys(data["root"])

        self.operator_type = data.pop("operator_type", None)

        self.identifiers = data.pop("identifiers", [])

        self.children = [CypherPlan(**self._clean_keys(child)) for child in data.pop("children", [])]

        try:

            args = data.pop("args")

        except KeyError:

            self.args = data

        else:

            self.args = self._clean_keys(args)



    def __repr__(self):

        return ("%s(operator_type=%r, identifiers=%r, children=%r, args=%r)" %

                (self.__class__.__name__, self.operator_type, self.identifiers, self.children, self.args))



    def __getitem__(self, key):

        return getattr(self, key)



    def __len__(self):

        return len(self.keys())



    def __iter__(self):

        return iter(self.keys())



    def keys(self):

        return ["operator_type", "identifiers", "children", "args"]

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





import re



from py2neo.cypher import cypher_escape, cypher_repr

from py2neo.data import Node

from py2neo.internal.collections import is_collection

from py2neo.internal.compat import Sequence, Set





_operators = {

    "exact": "=",

    "not": "<>",

    "regex": "=~",

    "gt": ">", "gte": ">=",

    "lt": "<", "lte": "<=",

    "startswith": "STARTS WITH",

    "endswith": "ENDS WITH",

    "contains": "CONTAINS",

}



_operators_search = "^(.+)__(%s)$" % "|".join(_operators.keys())





def _property_conditions(properties, offset=1):

    for i, (key, value) in enumerate(properties.items(), start=offset):

        if key == "__id__":

            condition = "id(_)"

        else:

            condition = "_.%s" % cypher_escape(key)

        if value is None:

            condition += " IS NULL"

            parameters = {}

        elif isinstance(value, (tuple, set, frozenset)):

            condition += " IN {%d}" % i

            parameters = {"%d" % i: list(value)}

        elif re.match(_operators_search, key):

            parts = re.search(_operators_search, key)

            prop = parts.group(1)

            operator = parts.group(2)

            condition = "_.%s %s {%d}" % (prop, _operators[operator], i)

            parameters = {"%d" % i: value}

        else:

            condition += " = {%d}" % i

            parameters = {"%d" % i: value}

        yield condition, parameters





class NodeMatch(object):

    """ Immutable set of node selection criteria.

    """



    def __init__(self, graph, labels=frozenset(), conditions=tuple(), order_by=tuple(), skip=None, limit=None):

        self.graph = graph

        self._labels = frozenset(labels)

        self._conditions = tuple(conditions)

        self._order_by = tuple(order_by)

        self._skip = skip

        self._limit = limit



    def __len__(self):

        """ Return the number of nodes matched.

        """

        return self.graph.evaluate(*self._query_and_parameters(count=True))



    def __iter__(self):

        """ Iterate through all matching nodes.

        """

        for record in self.graph.run(*self._query_and_parameters()):

            yield record[0]



    def first(self):

        """ Evaluate the match and return the first :class:`.Node`

        matched or :const:`None` if no matching nodes are found.



        :return: a single matching :class:`.Node` or :const:`None`

        """

        return self.graph.evaluate(*self._query_and_parameters())



    def _query_and_parameters(self, count=False):

        """ A tuple of the Cypher query and parameters used to select

        the nodes that match the criteria for this selection.



        :return: Cypher query string

        """

        clauses = ["MATCH (_%s)" % "".join(":%s" % cypher_escape(label) for label in self._labels)]

        parameters = {}

        if self._conditions:

            conditions = []

            for condition in self._conditions:

                if isinstance(condition, tuple):

                    condition, param = condition

                    parameters.update(param)

                conditions.append(condition)

            clauses.append("WHERE %s" % " AND ".join(conditions))

        if count:

            clauses.append("RETURN count(_)")

        else:

            clauses.append("RETURN _")

            if self._order_by:

                clauses.append("ORDER BY %s" % (", ".join(self._order_by)))

            if self._skip:

                clauses.append("SKIP %d" % self._skip)

            if self._limit is not None:

                clauses.append("LIMIT %d" % self._limit)

        return " ".join(clauses), parameters



    def where(self, *conditions, **properties):

        """ Refine this match to create a new match. The criteria specified

        for refining the match consist of conditions and properties.

        Conditions are individual Cypher expressions that would be found

        in a `WHERE` clause; properties are used as exact matches for

        property values.



        To refer to the current node within a condition expression, use

        the underscore character ``_``. For example::



            match.where("_.name =~ 'J.*'")



        Simple property equalities can also be specified::



            match.where(born=1976)



        :param conditions: Cypher expressions to add to the `WHERE` clause

        :param properties: exact property match keys and values

        :return: refined :class:`.NodeMatch` object

        """

        return self.__class__(self.graph, self._labels,

                              self._conditions + conditions + tuple(_property_conditions(properties)),

                              self._order_by, self._skip, self._limit)



    def order_by(self, *fields):

        """ Order by the fields or field expressions specified.



        To refer to the current node within a field or field expression,

        use the underscore character ``_``. For example::



            match.order_by("_.name", "max(_.a, _.b)")



        :param fields: fields or field expressions to order by

        :return: refined :class:`.NodeMatch` object

        """

        return self.__class__(self.graph, self._labels, self._conditions,

                              fields, self._skip, self._limit)



    def skip(self, amount):

        """ Skip the first `amount` nodes in the result.



        :param amount: number of nodes to skip

        :return: refined :class:`.NodeMatch` object

        """

        return self.__class__(self.graph, self._labels, self._conditions,

                              self._order_by, amount, self._limit)



    def limit(self, amount):

        """ Limit to at most `amount` nodes.



        :param amount: maximum number of nodes to return

        :return: refined :class:`.NodeMatch` object

        """

        return self.__class__(self.graph, self._labels, self._conditions,

                              self._order_by, self._skip, amount)





class NodeMatcher(object):

    """ Base matcher for selecting nodes that fulfil a specific set of

    criteria.



    :param graph: :class:`.Graph` object on which to perform matches

    """



    _match_class = NodeMatch



    def __init__(self, graph):

        self.graph = graph



    def __len__(self):

        """ Return the number of nodes matched.

        """

        return len(self.match())



    def __getitem__(self, identity):

        """ Return a node by identity.

        """

        entity = self.get(identity)

        if entity is None:

            raise KeyError("Node %d not found" % identity)

        return entity



    def get(self, identity):

        """ Create a new :class:`.NodeMatch` that filters by identity and

        returns the first matched :class:`.Node`. This can essentially be

        used to match and return a :class:`.Node` by ID.



            matcher.get(1234)



        If no such :class:`.Node` is found, py:const:`None` is returned

        instead. Contrast with `matcher[1234]` which raises a `KeyError`

        if no entity is found.

        """

        t = type(identity)

        if issubclass(t, (list, tuple, set, frozenset)):

            missing = [i for i in identity if i not in self.graph.node_cache]

            if missing:

                list(self.match().where("id(_) in %s" % cypher_repr(missing)))

            return t(self.graph.node_cache.get(i) for i in identity)

        else:

            try:

                return self.graph.node_cache[identity]

            except KeyError:

                return self.match().where("id(_) = %d" % identity).first()



    def match(self, *labels, **properties):

        """ Describe a basic node match using labels and property equality.



        :param labels: node labels to match

        :param properties: set of property keys and values to match

        :return: :class:`.NodeMatch` instance

        """

        criteria = {}

        if labels:

            criteria["labels"] = frozenset(labels)

        if properties:

            criteria["conditions"] = tuple(_property_conditions(properties))

        return self._match_class(self.graph, **criteria)





class RelationshipMatch(object):

    """ Immutable set of relationship selection criteria.

    """



    def __init__(self, graph, nodes=None, r_type=None,

                 conditions=tuple(), order_by=tuple(), skip=None, limit=None):

        if nodes is not None and not isinstance(nodes, (Sequence, Set)):

            raise ValueError("Nodes must be supplied as a Sequence or a Set")

        self.graph = graph

        self._nodes = nodes

        self._r_type = r_type

        self._conditions = tuple(conditions)

        self._order_by = tuple(order_by)

        self._skip = skip

        self._limit = limit



    def __len__(self):

        """ Return the number of relationships matched.

        """

        return self.graph.evaluate(*self._query_and_parameters(count=True))



    def __iter__(self):

        """ Iterate through all matching relationships.

        """

        query, parameters = self._query_and_parameters()

        for record in self.graph.run(query, parameters):

            yield record[0]



    def first(self):

        """ Evaluate the selection and return the first

        :class:`.Relationship` selected or :const:`None` if no matching

        relationships are found.



        :return: a single matching :class:`.Relationship` or :const:`None`

        """

        return self.graph.evaluate(*self._query_and_parameters())



    def _query_and_parameters(self, count=False):

        """ A tuple of the Cypher query and parameters used to select

        the relationships that match the criteria for this selection.



        :return: Cypher query string

        """



        def verify_node(n):

            if n.graph != self.graph:

                raise ValueError("Node %r does not belong to this graph" % n)

            if n.identity is None:

                raise ValueError("Node %r is not bound to a graph" % n)



        def r_type_name(r):

            try:

                return r.__name__

            except AttributeError:

                return r



        clauses = []

        parameters = {}

        if self._r_type is None:

            relationship_detail = ""

        elif is_collection(self._r_type):

            relationship_detail = ":" + "|:".join(cypher_escape(r_type_name(t)) for t in self._r_type)

        else:

            relationship_detail = ":%s" % cypher_escape(r_type_name(self._r_type))

        if not self._nodes:

            clauses.append("MATCH (a)-[_" + relationship_detail + "]->(b)")

        elif isinstance(self._nodes, Sequence):

            if len(self._nodes) >= 1 and self._nodes[0] is not None:

                start_node = Node.cast(self._nodes[0])

                verify_node(start_node)

                clauses.append("MATCH (a) WHERE id(a) = {x}")

                parameters["x"] = start_node.identity

            if len(self._nodes) >= 2 and self._nodes[1] is not None:

                end_node = Node.cast(self._nodes[1])

                verify_node(end_node)

                clauses.append("MATCH (b) WHERE id(b) = {y}")

                parameters["y"] = end_node.identity

            if len(self._nodes) >= 3:

                raise ValueError("Node sequence cannot be longer than two")

            clauses.append("MATCH (a)-[_" + relationship_detail + "]->(b)")

        elif isinstance(self._nodes, Set):

            nodes = {node for node in self._nodes if node is not None}

            if len(nodes) >= 1:

                start_node = Node.cast(nodes.pop())

                verify_node(start_node)

                clauses.append("MATCH (a) WHERE id(a) = {x}")

                parameters["x"] = start_node.identity

            if len(nodes) >= 1:

                end_node = Node.cast(nodes.pop())

                verify_node(end_node)

                clauses.append("MATCH (b) WHERE id(b) = {y}")

                parameters["y"] = end_node.identity

            if len(nodes) >= 1:

                raise ValueError("Node set cannot be larger than two")

            clauses.append("MATCH (a)-[_" + relationship_detail + "]-(b)")

        else:

            raise ValueError("Nodes must be passed as a Sequence or a Set")

        if self._conditions:

            conditions = []

            for condition in self._conditions:

                if isinstance(condition, tuple):

                    condition, param = condition

                    parameters.update(param)

                conditions.append(condition)

            clauses.append("WHERE %s" % " AND ".join(conditions))

        if count:

            clauses.append("RETURN count(_)")

        else:

            clauses.append("RETURN _")

            if self._order_by:

                clauses.append("ORDER BY %s" % (", ".join(self._order_by)))

            if self._skip:

                clauses.append("SKIP %d" % self._skip)

            if self._limit is not None:

                clauses.append("LIMIT %d" % self._limit)

        return " ".join(clauses), parameters



    def where(self, *conditions, **properties):

        """ Refine this match to create a new match. The criteria specified

        for refining the match consist of conditions and properties.

        Conditions are individual Cypher expressions that would be found

        in a `WHERE` clause; properties are used as exact matches for

        property values.



        To refer to the current relationship within a condition expression,

        use the underscore character ``_``. For example::



            match.where("_.weight >= 30")



        Simple property equalities can also be specified::



            match.where(since=1999)



        :param conditions: Cypher expressions to add to the `WHERE` clause

        :param properties: exact property match keys and values

        :return: refined :class:`.RelationshipMatch` object

        """

        return self.__class__(self.graph,

                              nodes=self._nodes,

                              r_type=self._r_type,

                              conditions=self._conditions + conditions + tuple(_property_conditions(properties)),

                              order_by=self._order_by,

                              skip=self._skip,

                              limit=self._limit)



    def order_by(self, *fields):

        """ Order by the fields or field expressions specified.



        To refer to the current relationship within a field or field

        expression, use the underscore character ``_``. For example::



            match.order_by("_.weight", "max(_.a, _.b)")



        :param fields: fields or field expressions to order by

        :return: refined :class:`.RelationshipMatch` object

        """

        return self.__class__(self.graph,

                              nodes=self._nodes,

                              r_type=self._r_type,

                              conditions=self._conditions,

                              order_by=fields,

                              skip=self._skip,

                              limit=self._limit)



    def skip(self, amount):

        """ Skip the first `amount` relationships in the result.



        :param amount: number of relationships to skip

        :return: refined :class:`.RelationshipMatch` object

        """

        return self.__class__(self.graph,

                              nodes=self._nodes,

                              r_type=self._r_type,

                              conditions=self._conditions,

                              order_by=self._order_by,

                              skip=amount,

                              limit=self._limit)



    def limit(self, amount):

        """ Limit to at most `amount` relationships.



        :param amount: maximum number of relationships to return

        :return: refined :class:`.RelationshipMatch` object

        """

        return self.__class__(self.graph,

                              nodes=self._nodes,

                              r_type=self._r_type,

                              conditions=self._conditions,

                              order_by=self._order_by,

                              skip=self._skip,

                              limit=amount)





class RelationshipMatcher(object):

    """ Base matcher for selecting relationships that fulfil a specific

    set of criteria.



    :param graph: :class:`.Graph` object on which to perform matches

    """



    _match_class = RelationshipMatch



    def __init__(self, graph):

        self.graph = graph

        self._all = self._match_class(self.graph)



    def __len__(self):

        """ Return the number of relationships matched.

        """

        return len(self.match())



    def __getitem__(self, identity):

        """ Return a relationship by identity.

        """

        entity = self.get(identity)

        if entity is None:

            raise KeyError("Relationship %d not found" % identity)

        return entity



    def get(self, identity):

        """ Create a new :class:`.RelationshipMatch` that filters by identity and

        returns the first matched :class:`.Relationship`. This can essentially be

        used to match and return a :class:`.Relationship` by ID.



            matcher.get(1234)



        If no such :class:`.Relationship` is found, py:const:`None` is returned

        instead. Contrast with `matcher[1234]` which raises a `KeyError`

        if no entity is found.

        """

        t = type(identity)

        if issubclass(t, (list, tuple, set, frozenset)):

            missing = [i for i in identity if i not in self.graph.relationship_cache]

            if missing:

                list(self.match().where("id(_) in %s" % cypher_repr(missing)))

            return t(self.graph.relationship_cache.get(i) for i in identity)

        else:

            try:

                return self.graph.relationship_cache[identity]

            except KeyError:

                return self.match().where("id(_) = %d" % identity).first()



    def match(self, nodes=None, r_type=None, **properties):

        """ Describe a basic relationship match...



        :param nodes: Sequence or Set of start and end nodes (:const:`None` means any node);

                a Set implies a match in any direction

        :param r_type:

        :param properties: set of property keys and values to match

        :return: :class:`.RelationshipMatch` instance

        """

        criteria = {}

        if nodes is not None:

            criteria["nodes"] = nodes

        if r_type is not None:

            criteria["r_type"] = r_type

        if properties:

            criteria["conditions"] = tuple(_property_conditions(properties))

        return self._match_class(self.graph, **criteria)

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





__all__ = ["__author__", "__copyright__", "__email__", "__license__", "__package__", "__version__",

           "NEO4J_URI", "NEO4J_AUTH", "NEO4J_USER_AGENT", "NEO4J_SECURE", "NEO4J_VERIFIED",

           "bolt_user_agent", "http_user_agent"]



__author__ = "Nigel Small <technige@nige.tech>"

__copyright__ = "2011-2019, Nigel Small"

__email__ = "py2neo@nige.tech"

__license__ = "Apache License, Version 2.0"

__package__ = "py2neo"

__version__ = "4.3.0"





from os import getenv





NEO4J_URI = getenv("NEO4J_URI")

NEO4J_AUTH = getenv("NEO4J_AUTH")

NEO4J_USER_AGENT = getenv("NEO4J_USER_AGENT")

NEO4J_SECURE = True if getenv("NEO4J_SECURE") == "1" else False if getenv("NEO4J_SECURE") == "0" else None

NEO4J_VERIFIED = True if getenv("NEO4J_VERIFIED") == "1" else False if getenv("NEO4J_VERIFIED") == "0" else None





def bolt_user_agent():

    from sys import platform, version_info

    from neobolt.meta import version as neobolt_version

    fields = (__package__, __version__, neobolt_version,) + tuple(version_info) + (platform,)

    return "{}/{} neobolt/{} Python/{}.{}.{}-{}-{} ({})".format(*fields)





def http_user_agent():

    from sys import platform, version_info

    import urllib3

    fields = (__package__, __version__, urllib3.__version__,) + tuple(version_info) + (platform,)

    return "{}/{} urllib3/{} Python/{}.{}.{}-{}-{} ({})".format(*fields)

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from py2neo.cypher import cypher_escape

from py2neo.data import Node, PropertyDict

from py2neo.internal.compat import metaclass

from py2neo.internal.text import Words

from py2neo.matching import NodeMatch, NodeMatcher





OUTGOING = 1

UNDIRECTED = 0

INCOMING = -1





def resolve_class(cls, instance):

    if isinstance(cls, type):

        return cls

    module_name, _, class_name = cls.rpartition(".")

    if not module_name:

        module_name = instance.__class__.__module__

    module = __import__(module_name, fromlist=".")

    return getattr(module, class_name)





class Property(object):

    """ Property definition for a :class:`.GraphObject`.



    Attributes:

        key: The name of the node property within the database.

        default: The default value for the property, if it would

                 otherwise be :const:`None`.

    """



    def __init__(self, key=None, default=None):

        """ Initialise a property definition.



        Args:

            key: The name of the node property within the database. If

                 omitted, the name of the class attribute is used.

            default: The default value for the property, if it would

                     otherwise be :const:`None`.

        """

        self.key = key

        self.default = default



    def __get__(self, instance, owner):

        value = instance.__node__[self.key]

        if value is None:

            value = self.default

        return value



    def __set__(self, instance, value):

        instance.__node__[self.key] = value





class Label(object):

    """ Label definition for a :class:`.GraphObject`.



    Labels are toggleable tags applied to an object that can be used as type

    information or other forms of classification.

    """



    def __init__(self, name=None):

        self.name = name



    def __get__(self, instance, owner):

        return instance.__node__.has_label(self.name)



    def __set__(self, instance, value):

        if value:

            instance.__node__.add_label(self.name)

        else:

            instance.__node__.remove_label(self.name)





class Related(object):

    """ Descriptor for a set of related objects in a :class:`.GraphObject`.



    Attributes:

        related_class: The class of object to which these relationships

                       connect. This class is used to coerce nodes to and

                       from :class:`GraphObject` instances.

        relationship_type: The underlying relationship type for these

                           relationships. Note that the relationship

                           type should be unique for each class of related

                           object as the `related_class` is only used for

                           object coercion and not as part of the underlying

                           database query.

    """



    direction = UNDIRECTED



    def __init__(self, related_class, relationship_type=None):

        """ Initialise a property definition.



        Args:

            related_class: The class of object to which these relationships

                           connect.

            relationship_type: The underlying relationship type for these

                               relationships.

        """

        self.related_class = related_class

        self.relationship_type = relationship_type



    def __get__(self, instance, owner):

        return instance.__ogm__.related(self.direction, self.relationship_type,

                                        resolve_class(self.related_class, instance))





class RelatedTo(Related):

    """ Descriptor for a set of related objects for a :class:`.GraphObject`

    that are connected by outgoing relationships.

    """



    direction = OUTGOING





class RelatedFrom(Related):

    """ Descriptor for a set of related objects for a :class:`.GraphObject`

    that are connected by incoming relationships.

    """



    direction = INCOMING





class RelatedObjects(object):

    """ A set of similarly-typed and similarly-related objects,

    relative to a central node.

    """



    def __init__(self, node, direction, relationship_type, related_class):

        assert isinstance(direction, int) and not isinstance(direction, bool)

        self.node = node

        self.related_class = related_class

        self.__related_objects = None

        if direction > 0:

            self.__match_args = {"nodes": (self.node, None), "r_type": relationship_type}

            self.__start_node = False

            self.__end_node = True

            self.__relationship_pattern = "(a)-[_:%s]->(b)" % cypher_escape(relationship_type)

        elif direction < 0:

            self.__match_args = {"nodes": (None, self.node), "r_type": relationship_type}

            self.__start_node = True

            self.__end_node = False

            self.__relationship_pattern = "(a)<-[_:%s]-(b)" % cypher_escape(relationship_type)

        else:

            self.__match_args = {"nodes": {self.node, None}, "r_type": relationship_type}

            self.__start_node = True

            self.__end_node = True

            self.__relationship_pattern = "(a)-[_:%s]-(b)" % cypher_escape(relationship_type)



    def __iter__(self):

        for obj, _ in self._related_objects:

            yield obj



    def __len__(self):

        return len(self._related_objects)



    def __contains__(self, obj):

        for related_object, _ in self._related_objects:

            if related_object == obj:

                return True

        return False



    @property

    def _related_objects(self):

        if self.__related_objects is None:

            self.__related_objects = []

            if self.node.graph:

                with self.node.graph.begin() as tx:

                    self.__db_pull__(tx)

        return self.__related_objects



    def add(self, obj, properties=None, **kwproperties):

        """ Add a related object.



        :param obj: the :py:class:`.GraphObject` to relate

        :param properties: dictionary of properties to attach to the relationship (optional)

        :param kwproperties: additional keyword properties (optional)

        """

        related_objects = self._related_objects

        properties = PropertyDict(properties or {}, **kwproperties)

        added = False

        for i, (related_object, _) in enumerate(related_objects):

            if related_object == obj:

                related_objects[i] = (obj, properties)

                added = True

        if not added:

            related_objects.append((obj, properties))



    def clear(self):

        """ Remove all related objects from this set.

        """

        self._related_objects[:] = []



    def get(self, obj, key, default=None):

        """ Return a relationship property associated with a specific related object.



        :param obj: related object

        :param key: relationship property key

        :param default: default value, in case the key is not found

        :return: property value

        """

        for related_object, properties in self._related_objects:

            if related_object == obj:

                return properties.get(key, default)

        return default



    def remove(self, obj):

        """ Remove a related object.



        :param obj: the :py:class:`.GraphObject` to separate

        """

        related_objects = self._related_objects

        related_objects[:] = [(related_object, properties)

                              for related_object, properties in related_objects

                              if related_object != obj]



    def update(self, obj, properties=None, **kwproperties):

        """ Add or update a related object.



        :param obj: the :py:class:`.GraphObject` to relate

        :param properties: dictionary of properties to attach to the relationship (optional)

        :param kwproperties: additional keyword properties (optional)

        """

        related_objects = self._related_objects

        properties = dict(properties or {}, **kwproperties)

        added = False

        for i, (related_object, p) in enumerate(related_objects):

            if related_object == obj:

                related_objects[i] = (obj, PropertyDict(p, **properties))

                added = True

        if not added:

            related_objects.append((obj, properties))



    def __db_pull__(self, tx):

        related_objects = {}

        for r in tx.graph.match(**self.__match_args):

            nodes = []

            n = self.node

            a = r.start_node

            b = r.end_node

            if a == b:

                nodes.append(a)

            else:

                if self.__start_node and a != n:

                    nodes.append(r.start_node)

                if self.__end_node and b != n:

                    nodes.append(r.end_node)

            for node in nodes:

                related_object = self.related_class.wrap(node)

                related_objects[node] = (related_object, PropertyDict(r))

        self._related_objects[:] = related_objects.values()



    def __db_push__(self, tx):

        related_objects = self._related_objects

        # 1. merge all nodes (create ones that don't)

        for related_object, _ in related_objects:

            tx.merge(related_object)

        # 2a. remove any relationships not in list of nodes

        subject_id = self.node.identity

        tx.run("MATCH %s WHERE id(a) = {x} AND NOT id(b) IN {y} DELETE _" % self.__relationship_pattern,

               x=subject_id, y=[obj.__node__.identity for obj, _ in related_objects])

        # 2b. merge all relationships

        for related_object, properties in related_objects:

            tx.run("MATCH (a) WHERE id(a) = {x} MATCH (b) WHERE id(b) = {y} "

                   "MERGE %s SET _ = {z}" % self.__relationship_pattern,

                   x=subject_id, y=related_object.__node__.identity, z=properties)





class OGM(object):



    def __init__(self, node):

        self.node = node

        self._related = {}



    def all_related(self):

        """ Return an iterator through all :class:`.RelatedObjects`.

        """

        return iter(self._related.values())



    def related(self, direction, relationship_type, related_class):

        """ Return :class:`.RelatedObjects` for given criteria.

        """

        key = (direction, relationship_type)

        if key not in self._related:

            self._related[key] = RelatedObjects(self.node, direction, relationship_type, related_class)

        return self._related[key]





class GraphObjectType(type):



    def __new__(mcs, name, bases, attributes):

        for attr_name, attr in list(attributes.items()):

            if isinstance(attr, Property):

                if attr.key is None:

                    attr.key = attr_name

            elif isinstance(attr, Label):

                if attr.name is None:

                    attr.name = Words(attr_name).camel(upper_first=True)

            elif isinstance(attr, Related):

                if attr.relationship_type is None:

                    attr.relationship_type = Words(attr_name).upper("_")



        attributes.setdefault("__primarylabel__", name)



        primary_key = attributes.get("__primarykey__")

        if primary_key is None:

            for base in bases:

                if primary_key is None and hasattr(base, "__primarykey__"):

                    primary_key = getattr(base, "__primarykey__")

                    break

            else:

                primary_key = "__id__"

            attributes["__primarykey__"] = primary_key



        return super(GraphObjectType, mcs).__new__(mcs, name, bases, attributes)





@metaclass(GraphObjectType)

class GraphObject(object):

    """ The base class for all OGM classes.

    """



    __primarylabel__ = None

    __primarykey__ = None



    __ogm = None



    def __eq__(self, other):

        if self is other:

            return True

        try:

            self_node = self.__node__

            other_node = other.__node__

            if any(x is None for x in [self_node.graph, other_node.graph, self_node.identity, other_node.identity]):

                return self.__primarylabel__ == other.__primarylabel__ and \

                       self.__primarykey__ == other.__primarykey__ and \

                       self.__primaryvalue__ == other.__primaryvalue__

            return (type(self) is type(other) and

                    self_node.graph == other_node.graph and

                    self_node.identity == other_node.identity)

        except (AttributeError, TypeError):

            return False



    def __ne__(self, other):

        return not self.__eq__(other)



    @property

    def __ogm__(self):

        if self.__ogm is None:

            self.__ogm = OGM(Node(self.__primarylabel__))

        node = self.__ogm.node

        if not hasattr(node, "__primarylabel__"):

            setattr(node, "__primarylabel__", self.__primarylabel__)

        if not hasattr(node, "__primarykey__"):

            setattr(node, "__primarykey__", self.__primarykey__)

        return self.__ogm



    @classmethod

    def wrap(cls, node):

        """ Convert a :class:`.Node` into a :class:`.GraphObject`.



        :param node:

        :return:

        """

        if node is None:

            return None

        inst = GraphObject()

        inst.__ogm = OGM(node)

        inst.__class__ = cls

        return inst



    @classmethod

    def match(cls, graph, primary_value=None):

        """ Select one or more nodes from the database, wrapped as instances of this class.



        :param graph: the :class:`.Graph` instance in which to match

        :param primary_value: value of the primary property (optional)

        :rtype: :class:`.GraphObjectMatch`

        """

        return GraphObjectMatcher(cls, graph).match(primary_value)



    def __repr__(self):

        return "<%s %s=%r>" % (self.__class__.__name__, self.__primarykey__, self.__primaryvalue__)



    @property

    def __primaryvalue__(self):

        node = self.__node__

        primary_key = self.__primarykey__

        if primary_key == "__id__":

            return node.identity

        else:

            return node[primary_key]



    @property

    def __node__(self):

        """ The :class:`.Node` wrapped by this :class:`.GraphObject`.

        """

        return self.__ogm__.node



    def __db_create__(self, tx):

        self.__db_merge__(tx)



    def __db_delete__(self, tx):

        ogm = self.__ogm__

        tx.delete(ogm.node)

        for related_objects in ogm.all_related():

            related_objects.clear()



    def __db_exists__(self, tx):

        return tx.exists(self.__node__)



    def __db_merge__(self, tx, primary_label=None, primary_key=None):

        ogm = self.__ogm__

        node = ogm.node

        if primary_label is None:

            primary_label = getattr(node, "__primarylabel__", None)

        if primary_key is None:

            primary_key = getattr(node, "__primarykey__", "__id__")

        if node.graph is None:

            if primary_key == "__id__":

                node.add_label(primary_label)

                tx.create(node)

            else:

                tx.merge(node, primary_label, primary_key)

            for related_objects in ogm.all_related():

                related_objects.__db_push__(tx)



    def __db_pull__(self, tx):

        ogm = self.__ogm__

        if ogm.node.graph is None:

            matcher = GraphObjectMatcher(self.__class__, tx.graph)

            matcher._match_class = NodeMatch

            ogm.node = matcher.match(self.__primaryvalue__).first()

        tx.pull(ogm.node)

        for related_objects in ogm.all_related():

            related_objects.__db_pull__(tx)



    def __db_push__(self, tx):

        ogm = self.__ogm__

        node = ogm.node

        if node.graph is not None:

            tx.push(node)

        else:

            primary_key = getattr(node, "__primarykey__", "__id__")

            if primary_key == "__id__":

                tx.create(node)

            else:

                tx.merge(node)

        for related_objects in ogm.all_related():

            related_objects.__db_push__(tx)





class GraphObjectMatch(NodeMatch):

    """ A selection of :class:`.GraphObject` instances that match a

    given set of criteria.

    """



    _object_class = GraphObject



    def __iter__(self):

        """ Iterate through items drawn from the underlying graph that

        match the given criteria.

        """

        wrap = self._object_class.wrap

        for node in super(GraphObjectMatch, self).__iter__():

            yield wrap(node)



    def first(self):

        """ Return the first item that matches the given criteria.

        """

        return self._object_class.wrap(super(GraphObjectMatch, self).first())





class GraphObjectMatcher(NodeMatcher):



    _match_class = GraphObjectMatch



    def __init__(self, object_class, graph):

        NodeMatcher.__init__(self, graph)

        self._object_class = object_class

        self._match_class = type("%sMatch" % self._object_class.__name__,

                                 (GraphObjectMatch,), {"_object_class": object_class})



    def match(self, primary_value=None):

        cls = self._object_class

        properties = {}

        if primary_value is not None:

            properties[cls.__primarykey__] = primary_value

        return NodeMatcher.match(self, cls.__primarylabel__, **properties)

#!/usr/bin/env python

# -*- encoding: utf-8 -*-



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





from py2neo.data import *

from py2neo.database import *

from py2neo.meta import *

from py2neo.matching import *

#!/usr/bin/env python

# coding: utf-8



# Copyright 2011-2019, Nigel Small

#

# Licensed under the Apache License, Version 2.0 (the "License");

# you may not use this file except in compliance with the License.

# You may obtain a copy of the License at

#

#     http://www.apache.org/licenses/LICENSE-2.0

#

# Unless required by applicable law or agreed to in writing, software

# distributed under the License is distributed on an "AS IS" BASIS,

# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

# See the License for the specific language governing permissions and

# limitations under the License.





import click



from py2neo.meta import NEO4J_URI, NEO4J_AUTH





@click.group(help="""\

Multipurpose Neo4j toolkit.

""")

def py2neo():

    pass





@py2neo.command("version", help="""\

Display the current library version

""")

def py2neo_version():

    from py2neo.meta import __version__

    click.echo(__version__)





@py2neo.command("console", help="""\

Interactive Cypher console

""")

@click.option("-u", "--uri", default=NEO4J_URI, help="Set the connection URI.")

@click.option("-a", "--auth", default=NEO4J_AUTH, help="Set the user and password.")

@click.option("-s", "--secure", is_flag=True, default=False, help="Use encrypted communication (TLS).")

@click.option("-v", "--verbose", is_flag=True, default=False, help="Show low level communication detail.")

def py2neo_console(uri, auth=None, secure=None, verbose=None):

    from py2neo.console import Console, ConsoleError

    try:

        con = Console(uri, auth=auth, secure=secure, verbose=verbose)

    except ConsoleError as error:

        click.echo(error)

        raise SystemExit(1)

    else:

        raise SystemExit(con.loop())





@py2neo.group("auth", help="""\

Auth file management

""")

def py2neo_auth():

    pass





@py2neo_auth.command("list", help="""\

List users

""")

@click.argument("auth_file")

def py2neo_auth_list(auth_file):

    from py2neo.admin.install import AuthFile

    for user in AuthFile(auth_file):

        click.echo(user.name)





@py2neo_auth.command("remove", help="""\

Remove a user



Example:



    py2neo auth remove data/dbms/auth alice

    

""")

@click.argument("auth_file")

@click.argument("user_name")

def py2neo_auth_remove(auth_file, user_name):

    from py2neo.admin.install import AuthFile

    AuthFile(auth_file).remove(user_name)





@py2neo_auth.command("update", help="""\

Create a user or set a password



For general interactive use, password and confirmation prompts will be presented.

For batch mode, use the --password option.



Example:



    py2neo auth update data/dbms/auth alice



If AUTH_FILE contains only a dash `-` then the auth file entry will be written to stdout instead.

""")

@click.argument("auth_file")

@click.argument("user_name")

@click.password_option()

def py2neo_auth_update(auth_file, user_name, password):

    from py2neo.admin.install import AuthFile

    AuthFile(auth_file).update(user_name, password)





@py2neo.command("get", help="""\

Download a Neo4j distribution

""")

def py2neo_get():

    from py2neo.admin.dist import Distribution

    Distribution().download()





@py2neo.command("run", help="""\

Run a Cypher query

""")

@click.option("-u", "--uri", default=NEO4J_URI, help="Set the connection URI.")

@click.option("-a", "--auth", default=NEO4J_AUTH, help="Set the user and password.")

@click.option("-s", "--secure", is_flag=True, default=False, help="Use encrypted communication (TLS).")

@click.option("-v", "--verbose", is_flag=True, default=False, help="Show low level communication detail.")

@click.argument("cypher", nargs=-1)

def py2neo_run(cypher, uri, auth=None, secure=None, verbose=None):

    from py2neo.console import Console, ConsoleError

    try:

        con = Console(uri, auth=auth, secure=secure, verbose=verbose)

    except ConsoleError as error:

        click.echo(error)

        raise SystemExit(1)

    else:

        raise SystemExit(con.run_all(cypher))





def main():

    try:

        py2neo(obj={})

    except Exception as error:

        click.secho(error.args[0], err=True)

        exit(1)

    else:

        exit(0)





if __name__ == "__main__":

    main()

